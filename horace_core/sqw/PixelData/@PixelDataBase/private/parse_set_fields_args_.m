function [pix_fields, abs_pix_indices] = parse_set_fields_args_(obj, pix_fields, data, varargin)
% process inputs for set_raw_fields function
%
NO_INPUT_INDICES = -1;

validateattributes(pix_fields, {'cell', 'char', 'string'}, {'nonempty'}, 'pix_fields');
validateattributes(data, {'numeric'}, {}, 'data');

parser = inputParser();
parser.addOptional( ...
    'abs_pix_indices', ...
    NO_INPUT_INDICES, ...
    @(x) validateattributes(x, {'numeric', 'logical'}, {'integer', 'nonnegative'}) ...
    );
parser.parse(varargin{:});
abs_pix_indices = parser.Results.abs_pix_indices;

pix_fields = cellstr(pix_fields);
pix_fields = obj.check_pixel_fields(pix_fields);

if islogical(abs_pix_indices)
    abs_pix_indices = logical_to_normal_index_(obj, abs_pix_indices);
end

if size(data, 1) ~= numel(pix_fields)
    error( ...
        'HORACE:PixelData:invalid_argument', ...
        ['Number of fields in ''pix_fields'' must be equal to number ' ...
        'of columns in ''data''.\nn_pix_fields: %i n_data_columns: %i.'], ...
        numel(pix_fields), size(data, 1) ...
        );
end
if ~isequal(abs_pix_indices, NO_INPUT_INDICES) && size(data, 2) ~= numel(abs_pix_indices)
    error( ...
        'HORACE:PixelData:invalid_argument', ...
        ['Number of indices in ''abs_pix_indices'' must be equal to ' ...
        'number of rows in ''data''.\nFound %i and %i.'], ...
        numel(abs_pix_indices), size(data, 2) ...
        );
end
end
