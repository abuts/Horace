<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>API Reference &mdash; Horace  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="General disclaimer" href="General_disclaimer.html" />
    <link rel="prev" title="Contributing to Horace" href="Contributing.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Horace
            <img src="_static/150px-Quintus_Horatius_Flaccus.jpg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">Introduction and Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="User_guide.html">User’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="Horace_manual.html">Horace Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="Citing.html">Citing Horace</a></li>
<li class="toctree-l1"><a class="reference internal" href="Developers.html">For Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="Contributing.html">Contributing to Horace</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-sqw.&#64;SQWDnDBase"><code class="docutils literal notranslate"><span class="pre">SQWDndBase</span></code> class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-sqw.&#64;Experiment"><code class="docutils literal notranslate"><span class="pre">Experiment</span></code> class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-sqw.PixelData.&#64;PixelData"><code class="docutils literal notranslate"><span class="pre">PixelData</span></code> class</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="General_disclaimer.html">General disclaimer</a></li>
<li class="toctree-l1"><a class="reference internal" href="Privacy_policy.html">Privacy Policy</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Horace</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>API Reference</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/API_Reference.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="api-reference">
<h1><a class="toc-backref" href="#id111">API Reference</a><a class="headerlink" href="#api-reference" title="Permalink to this heading"></a></h1>
<div class="contents topic" id="table-of-contents">
<p class="topic-title">Table of Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#api-reference" id="id111">API Reference</a></p>
<ul>
<li><p><a class="reference internal" href="#module-sqw.&#64;SQWDnDBase" id="id112"><code class="docutils literal notranslate"><span class="pre">SQWDndBase</span></code> class</a></p></li>
<li><p><a class="reference internal" href="#module-sqw.&#64;Experiment" id="id113"><code class="docutils literal notranslate"><span class="pre">Experiment</span></code> class</a></p></li>
<li><p><a class="reference internal" href="#module-sqw.PixelData.&#64;PixelData" id="id114"><code class="docutils literal notranslate"><span class="pre">PixelData</span></code> class</a></p></li>
</ul>
</li>
</ul>
</div>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">API Index</span></a></p></li>
</ul>
<section id="module-sqw.&#64;SQWDnDBase">
<span id="sqwdndbase-class"></span><h2><a class="toc-backref" href="#id112"><code class="docutils literal notranslate"><span class="pre">SQWDndBase</span></code> class</a><a class="headerlink" href="#module-sqw.@SQWDnDBase" title="Permalink to this heading"></a></h2>
<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.IX_dataset_1d">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">IX_dataset_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.IX_dataset_1d" title="Permalink to this definition"></a></dt>
<dd><p>Convert 1D sqw object into IX_dataset_1d</p>
<p>&gt;&gt; wout = IX_dataset_1d (w)</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.IX_dataset_2d">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">IX_dataset_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.IX_dataset_2d" title="Permalink to this definition"></a></dt>
<dd><p>Convert 2D sqw object(s) into IX_dataset_2d(s)</p>
<p>&gt;&gt; wout = IX_dataset_2d (w)</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.IX_dataset_3d">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">IX_dataset_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.IX_dataset_3d" title="Permalink to this definition"></a></dt>
<dd><p>Convert 3D sqw object into IX_dataset_3d</p>
<p>&gt;&gt; wout = IX_dataset_3d (w)</p>
</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.SQWDnDBase">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">SQWDnDBase</span></span><a class="headerlink" href="#sqw.@SQWDnDBase.SQWDnDBase" title="Permalink to this definition"></a></dt>
<dd><p>SQWDnDBase Abstract SQW/DnD object base class</p>
<p>Abstract class defining common API and atrributes of the SQW and
DnD objects</p>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.SQWDnDBase.border_size">
<span class="sig-name descname"><span class="pre">border_size</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'-4*eps'</span></em><a class="headerlink" href="#sqw.@SQWDnDBase.SQWDnDBase.border_size" title="Permalink to this definition"></a></dt>
<dd><p>the size of the border, used in gen_sqw. The img_db_range in gen_sqw
exceeds real pix_range (or input pix_range) by this value.</p>
</dd></dl>

<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.SQWDnDBase.parse_change_crystal_arguments">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">parse_change_crystal_arguments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">alatt0</span></em>, <em class="sig-param"><span class="pre">angdeg0</span></em>, <em class="sig-param"><span class="pre">exper_info</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.SQWDnDBase.parse_change_crystal_arguments" title="Permalink to this definition"></a></dt>
<dd><p>process input parameters for change crystal routine and
return standard form of the arguments to use in change_crystal
Most commonly:</p>
<blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>&gt;&gt; [alatt,angdeg,cor_mat] = change_crystal (alatt0,angdeg0,exper_info,rlu_corr)</dt><dd><p>change lattice parameters and orientation</p>
</dd>
</dl>
</div></blockquote>
<p>where</p>
</div></blockquote>
<p>alat0   – initial lattice parametes stored in the sqw file
angdeg0 – initial lattice angles stored in the sqw file
exper_info – Experiment class, describing the experiment,</p>
<blockquote>
<div><blockquote>
<div><p>stored in sqw file
May be empty for dnd objects</p>
</div></blockquote>
<dl>
<dt>rlu_corr    Matrix to convert notional rlu in the current crystal lattice to</dt><dd><p>the rlu in the the new crystal lattice together with any re-orientation
of the crystal. The matrix is defined by the matrix:</p>
<blockquote>
<div><blockquote>
<div><p>qhkl(i) = rlu_corr(i,j) * qhkl_0(j)</p>
</div></blockquote>
<p>This matrix can be obtained from refining the lattice and</p>
</div></blockquote>
<p>orientation with the function refine_crystal (type
&gt;&gt; help refine_crystal  for more details).</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.acos">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">acos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.acos" title="Permalink to this definition"></a></dt>
<dd><p>Implements acos(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = acos(w1)</p>
</div></blockquote>
<section id="input">
<h3>Input:<a class="headerlink" href="#input" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="output">
<h3>Output:<a class="headerlink" href="#output" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.acosh">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">acosh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.acosh" title="Permalink to this definition"></a></dt>
<dd><p>Implements acosh(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = acosh(w1)</p>
</div></blockquote>
<section id="id1">
<h3>Input:<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id2">
<h3>Output:<a class="headerlink" href="#id2" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.acot">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">acot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.acot" title="Permalink to this definition"></a></dt>
<dd><p>Implements acot(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = acot(w1)</p>
</div></blockquote>
<section id="id3">
<h3>Input:<a class="headerlink" href="#id3" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id4">
<h3>Output:<a class="headerlink" href="#id4" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.acoth">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">acoth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.acoth" title="Permalink to this definition"></a></dt>
<dd><p>Implements acoth(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = acoth(w1)</p>
</div></blockquote>
<section id="id5">
<h3>Input:<a class="headerlink" href="#id5" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id6">
<h3>Output:<a class="headerlink" href="#id6" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.acsc">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">acsc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.acsc" title="Permalink to this definition"></a></dt>
<dd><p>Implements acsc(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = acsc(w1)</p>
</div></blockquote>
<section id="id7">
<h3>Input:<a class="headerlink" href="#id7" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id8">
<h3>Output:<a class="headerlink" href="#id8" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.acsch">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">acsch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.acsch" title="Permalink to this definition"></a></dt>
<dd><p>Implements acsch(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = acsch(w1)</p>
</div></blockquote>
<section id="id9">
<h3>Input:<a class="headerlink" href="#id9" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id10">
<h3>Output:<a class="headerlink" href="#id10" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.asec">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">asec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.asec" title="Permalink to this definition"></a></dt>
<dd><p>Implements asec(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = asec(w1)</p>
</div></blockquote>
<section id="id11">
<h3>Input:<a class="headerlink" href="#id11" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id12">
<h3>Output:<a class="headerlink" href="#id12" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.asech">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">asech</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.asech" title="Permalink to this definition"></a></dt>
<dd><p>Implements asech(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = asech(w1)</p>
</div></blockquote>
<section id="id13">
<h3>Input:<a class="headerlink" href="#id13" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id14">
<h3>Output:<a class="headerlink" href="#id14" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.asin">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">asin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.asin" title="Permalink to this definition"></a></dt>
<dd><p>Implements asin(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = asin(w1)</p>
</div></blockquote>
<section id="id15">
<h3>Input:<a class="headerlink" href="#id15" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id16">
<h3>Output:<a class="headerlink" href="#id16" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.asinh">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">asinh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.asinh" title="Permalink to this definition"></a></dt>
<dd><p>Implements asinh(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = asinh(w1)</p>
</div></blockquote>
<section id="id17">
<h3>Input:<a class="headerlink" href="#id17" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id18">
<h3>Output:<a class="headerlink" href="#id18" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.atan">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">atan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.atan" title="Permalink to this definition"></a></dt>
<dd><p>Implements atan(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = atan(w1)</p>
</div></blockquote>
<section id="id19">
<h3>Input:<a class="headerlink" href="#id19" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id20">
<h3>Output:<a class="headerlink" href="#id20" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.atanh">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">atanh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.atanh" title="Permalink to this definition"></a></dt>
<dd><p>Implements atanh(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = atanh(w1)</p>
</div></blockquote>
<section id="id21">
<h3>Input:<a class="headerlink" href="#id21" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id22">
<h3>Output:<a class="headerlink" href="#id22" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.binary_op_manager">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">binary_op_manager</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em>, <em class="sig-param"><span class="pre">w2</span></em>, <em class="sig-param"><span class="pre">binary_op</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.binary_op_manager" title="Permalink to this definition"></a></dt>
<dd><p>Implements a binary operation for objects with a signal and a variance array.</p>
<blockquote>
<div><p>&gt;&gt; w = binary_op_manager(w1, w2, binary_op)</p>
</div></blockquote>
<p>All binary operations on Matlab double arrays are permitted
(+, -, <a href="#id23"><span class="problematic" id="id24">*</span></a>, /, ) and are applied element by element to the signal and
variance arrays.</p>
<section id="id25">
<h3>Input:<a class="headerlink" href="#id25" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl>
<dt>w1, w2      Objects on which the binary operation is to be performed.</dt><dd><p>One of these can be a Matlab double (i.e. double precision)
array, in which case the variance array is taken to be zero.</p>
<p>If w1, w2 are scalar objects with the same signal array sizes:
- The operation is performed element-by-element.</p>
<p>If one of w1 or w2 is a double array (and the other is a
scalar object):
- If a scalar, apply to each element of the object signal.
- If it is an array of the same size as the object signal</p>
<blockquote>
<div><p>array, apply the operation element by element.</p>
</div></blockquote>
<p>If one or both of w1 and w2 are arrays of objects:
- If objects have same array sizes, the binary operation is</p>
<blockquote>
<div><p>applied object element-by-object element.</p>
</div></blockquote>
<ul class="simple">
<li><p>If one of the objects is scalar (i.e. only one object),</p></li>
</ul>
<blockquote>
<div><p>then it is applied by the binary operation to each object
in the other array.</p>
</div></blockquote>
<p>If one of w1, w2 is an array of objects and the other is a
double array:
- If the double is a scalar, it is applied to every object</p>
<blockquote>
<div><p>in the array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with the same size as the object</p></li>
</ul>
<blockquote>
<div><p>array, then each element is applied as a scalar to the
corresponding object in the object array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with larger size than the object</p></li>
</ul>
<blockquote>
<div><p>array, then the array is resolved into a stack of arrays,
where the stack has the same size as the object array, and
the each array in the stack is applied to the corresponding
object in the object array. [Note that for this operation
to be valid, each object must have the same signal array
size.]</p>
</div></blockquote>
</dd>
<dt>binary_op   Function handle to a binary operation. All binary operations</dt><dd><p>on Matlab double or single arrays are permitted (+, -, <a href="#id26"><span class="problematic" id="id27">*</span></a>,
/, ).</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id28">
<h3>Output:<a class="headerlink" href="#id28" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
<p>NOTES:
This is a generic method - works for any class (including sigvar)
so long as the methods below are defined on that class.</p>
<p>Requires that objects have the following methods to find the size of the
public signal and variance arrays, create a sigvar object from those
arrays, and set them from another sigvar object.</p>
<blockquote>
<div><dl class="simple">
<dt>&gt;&gt; sz = sigvar_size(obj)    % Returns size of public signal and variance</dt><dd><p>% arrays</p>
</dd>
<dt>&gt;&gt; w = sigvar(obj)          % Create a sigvar object from the public</dt><dd><p>% signal and variance arrays</p>
</dd>
<dt>&gt;&gt; obj = sigvar_set(obj,w)  % Set signal and variance in an object from</dt><dd><p>% those in a sigvar object</p>
</dd>
</dl>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.calculate_q_bins">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">calculate_q_bins</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.calculate_q_bins" title="Permalink to this definition"></a></dt>
<dd><p>Calculate qh,qk,ql,en for the centres of the bins of an n-dimensional sqw or dnd dataset</p>
<blockquote>
<div><p>&gt;&gt; [q,en]=calculate_q_bins(win)</p>
</div></blockquote>
<section id="id29">
<h3>Input:<a class="headerlink" href="#id29" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>win     Input sqw/dnd object</p>
</div></blockquote>
</section>
<section id="id30">
<h3>Output:<a class="headerlink" href="#id30" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl>
<dt>q       Components of momentum (in rlu) for each bin in the dataset for a single energy bin</dt><dd><p>Arrays are packaged as cell array of column vectors for convenience
with fitting routines etc.</p>
<blockquote>
<div><p>i.e. q{1}=qh, q{2}=qk, q{3}=ql</p>
</div></blockquote>
</dd>
<dt>en      Column vector of energy bin centres. If energy was an integration axis, then returns the</dt><dd><p>centre of the energy integration range</p>
</dd>
</dl>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.calculate_qw_bins">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">calculate_qw_bins</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">optstr</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.calculate_qw_bins" title="Permalink to this definition"></a></dt>
<dd><p>Calculate qh,qk,ql,en for the centres of the bins of an n-dimensional sqw or dnd dataset</p>
<blockquote>
<div><p>&gt;&gt; qw=calculate_qw_bins(win)
&gt;&gt; qw=calculate_qw_bins(win,’boundaries’)
&gt;&gt; qw=calculate_qw_bins(win,’edges’)</p>
</div></blockquote>
<section id="id31">
<h3>Input:<a class="headerlink" href="#id31" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>win         Input sqw or dnd object</p>
</div></blockquote>
<p>Optional arguments:
‘boundaries’  Return qh,qk,ql,en at verticies of bins, not centres
‘edges’       Return qh,qk,ql,en at verticies of the hyper cuboid that</p>
<blockquote>
<div><p>encloses the plot axes</p>
</div></blockquote>
</section>
<section id="id32">
<h3>Output:<a class="headerlink" href="#id32" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl>
<dt>qw          Components of momentum (in rlu) and energy for each bin in</dt><dd><p>the dataset Arrays are packaged as cell array of column vectors
for convenience with fitting routines etc.</p>
<blockquote>
<div><blockquote>
<div><p>i.e. qw{1}=qh, qw{2}=qk, qw{3}=ql, qw{4}=en</p>
</div></blockquote>
<p>Note that the centre of the integration range is used in</p>
</div></blockquote>
<p>the calculation of qh,qk,ql,en even with the options
‘boundaries’ or ‘edges’</p>
<blockquote>
<div><p>If one or both of the integration ranges is infinite, then</p>
</div></blockquote>
<p>the value of the corresponding coordinate is taken as zero.</p>
</dd>
</dl>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.change_crystal">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">change_crystal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.change_crystal" title="Permalink to this definition"></a></dt>
<dd><p>Change the crystal lattice and orientation of an sqw object or array of objects</p>
<dl class="simple">
<dt>Most commonly:</dt><dd><p>&gt;&gt; wout = change_crystal (w, rlu_corr)              % change lattice parameters and orientation</p>
</dd>
<dt>OR</dt><dd><p>&gt;&gt; wout = change_crystal (w, alatt)                 % change just length of lattice vectors
&gt;&gt; wout = change_crystal (w, alatt, angdeg)         % change all lattice parameters
&gt;&gt; wout = change_crystal (w, alatt, angdeg, rotmat) % change lattice parameters and orientation
&gt;&gt; wout = change_crystal (w, alatt, angdeg, u, v)   % change lattice parameters and redefine u, v</p>
</dd>
</dl>
<section id="id33">
<h3>Input:<a class="headerlink" href="#id33" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Input sqw object</p>
<dl>
<dt>rlu_corr    Matrix to convert notional rlu in the current crystal lattice to</dt><dd><p>the rlu in the the new crystal lattice together with any re-orientation
of the crystal. The matrix is defined by the matrix:</p>
<blockquote>
<div><blockquote>
<div><p>qhkl(i) = rlu_corr(i,j) * qhkl_0(j)</p>
</div></blockquote>
<p>This matrix can be obtained from refining the lattice and</p>
</div></blockquote>
<p>orientation with the function refine_crystal (type
&gt;&gt; help refine_crystal  for more details).</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt><em>OR</em></dt><dd><p>alatt       New lattice parameters [a,b,c] (Angstroms)
angdeg      New lattice angles [alf,bet,gam] (degrees)
rotmat      Rotation matrix that relates crystal Cartesian coordinate frame of the new</p>
<blockquote>
<div><p>lattice as a rotation of the current crystal frame. Orthonormal coordinates
in the two frames are related by</p>
<blockquote>
<div><p>v_new(i)= rotmat(i,j)*v_current(j)</p>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>u, v        Redefine the two vectors that were used to determine the scattering plane</dt><dd><p>These are the vectors at whatever disorientation angles dpsi, gl, gs (which
cannot be changed).</p>
</dd>
</dl>
</dd>
</dl>
</section>
<section id="id34">
<h3>Output:<a class="headerlink" href="#id34" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>wout        Output sqw object with changed crystal lattice parameters and orientation</p>
</div></blockquote>
<dl>
<dt>NOTE</dt><dd><p>The input data set(s) can be reset to their original orientation by inverting the
input data e.g.</p>
<blockquote>
<div><ul class="simple">
<li><p>call with inv(rlu_corr)</p></li>
<li><p>call with the original alatt, angdeg, u and v</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.compact">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">compact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.compact" title="Permalink to this definition"></a></dt>
<dd><p>Squeezes the data range in an sqw or dnd object to eliminate empty bins</p>
<dl class="simple">
<dt>Syntax:</dt><dd><p>&gt;&gt; wout = compact(win)</p>
</dd>
</dl>
<section id="id35">
<h3>Input:<a class="headerlink" href="#id35" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>win         Input object</p>
</div></blockquote>
</section>
<section id="id36">
<h3>Output:<a class="headerlink" href="#id36" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>wout        Output object, with length of axes reduced to yield the</dt><dd><p>smallest cuboid that contains the non-empty bins.</p>
</dd>
</dl>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.convert_bins_for_shoelace">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">convert_bins_for_shoelace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">wref</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.convert_bins_for_shoelace" title="Permalink to this definition"></a></dt>
<dd><p>Converts data in the d2d object win into appropriate format for the
shoelace rebinning function (i.e. bin corners rather than bin
boundaries). The co-ordinate system is defined by the d2d object wref. If
wref is empty then the co-ordinate system remains unchanged.</p>
<p>RAE 23/9/09</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.cos">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">cos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.cos" title="Permalink to this definition"></a></dt>
<dd><p>Implements cos(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = cos(w1)</p>
</div></blockquote>
<section id="id37">
<h3>Input:<a class="headerlink" href="#id37" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id38">
<h3>Output:<a class="headerlink" href="#id38" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.cosh">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">cosh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.cosh" title="Permalink to this definition"></a></dt>
<dd><p>Implements cosh(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = cosh(w1)</p>
</div></blockquote>
<section id="id39">
<h3>Input:<a class="headerlink" href="#id39" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id40">
<h3>Output:<a class="headerlink" href="#id40" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.cot">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">cot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.cot" title="Permalink to this definition"></a></dt>
<dd><p>Implements cot(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = cot(w1)</p>
</div></blockquote>
<section id="id41">
<h3>Input:<a class="headerlink" href="#id41" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id42">
<h3>Output:<a class="headerlink" href="#id42" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.coth">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">coth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.coth" title="Permalink to this definition"></a></dt>
<dd><p>Implements coth(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = coth(w1)</p>
</div></blockquote>
<section id="id43">
<h3>Input:<a class="headerlink" href="#id43" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id44">
<h3>Output:<a class="headerlink" href="#id44" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.csc">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">csc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.csc" title="Permalink to this definition"></a></dt>
<dd><p>Implements csc(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = csc(w1)</p>
</div></blockquote>
<section id="id45">
<h3>Input:<a class="headerlink" href="#id45" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id46">
<h3>Output:<a class="headerlink" href="#id46" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.csch">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">csch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.csch" title="Permalink to this definition"></a></dt>
<dd><p>Implements csch(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = csch(w1)</p>
</div></blockquote>
<section id="id47">
<h3>Input:<a class="headerlink" href="#id47" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id48">
<h3>Output:<a class="headerlink" href="#id48" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.disp2sqw_eval">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">disp2sqw_eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">dispreln</span></em>, <em class="sig-param"><span class="pre">pars</span></em>, <em class="sig-param"><span class="pre">fwhh</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.disp2sqw_eval" title="Permalink to this definition"></a></dt>
<dd><p>Calculate sqw for a model scattering function</p>
<blockquote>
<div><p>&gt;&gt; wout = disp2sqw_eval(win,dispreln,pars,fwhh,varargin)</p>
</div></blockquote>
<section id="id49">
<h3>Input:<a class="headerlink" href="#id49" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl>
<dt>win         Dataset, or array of datasets, that provides the axes and points</dt><dd><p>for the calculation</p>
</dd>
<dt>dispreln    Handle to function that calculates the dispersion relation w(Q) and</dt><dd><p>spectral weight, s(Q)
Must have form:</p>
<blockquote>
<div><blockquote>
<div><p>[w,s] = dispreln (qh,qk,ql,p)</p>
</div></blockquote>
<dl class="simple">
<dt>where</dt><dd><dl class="simple">
<dt>qh,qk,ql    Arrays containing the coordinates of a set of points</dt><dd><p>in reciprocal lattice units</p>
</dd>
<dt>p           Vector of parameters needed by dispersion function</dt><dd><p>e.g. [A,js,gam] as intensity, exchange, lifetime</p>
</dd>
<dt>w           Array of corresponding energies, or, if more than</dt><dd><p>one dispersion relation, a cell array of arrays.</p>
</dd>
<dt>s           Array of spectral weights, or, if more than</dt><dd><p>one dispersion relation, a cell array of arrays.</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>More general form is:</dt><dd><blockquote>
<div><p>[w,s] = dispreln (qh,qk,ql,p,c1,c2,..)</p>
</div></blockquote>
<dl class="simple">
<dt>where</dt><dd><dl class="simple">
<dt>p           Typically a vector of parameters that we might want</dt><dd><p>to fit in a least-squares algorithm</p>
</dd>
<dt>c1,c2,…   Other constant parameters e.g. file name for look-up</dt><dd><p>table.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>pars        Arguments needed by the function. Most commonly, a vector of parameter</dt><dd><p>values e.g. [A,js,gam] as intensity, exchange, lifetime. If a more general
set of parameters is required by the function, then
package these into a cell array and pass that as pars. In the example
above then pars = {p, c1, c2, …}</p>
</dd>
<dt>fwhh       Parametrizes the resolution function. There are three</dt><dd><blockquote>
<div><p>possible input values of fwhh:</p>
</div></blockquote>
<dl>
<dt>double              A single FWHM value determines the FWHM of the</dt><dd><p>Gaussian resolution function</p>
</dd>
<dt>function_handle     A function that produces the FWHM value as a</dt><dd><p>function of energy transfer, it has to have the
following simple header (where omega can be a row
vector of energies:</p>
<blockquote>
<div><p>dE = resfun(omega)</p>
</div></blockquote>
</dd>
<dt>function_handle     A function handle of a function with two input</dt><dd><dl class="simple">
<dt>parameters with the following header:</dt><dd><p>I = shapefun(Emat,omega)</p>
</dd>
</dl>
<p>where Emat is a matrix with dimensions of [nQ nE]
and omega is a column vector with nQ elements. The
shapefun produces a peakshape for every Q point
centered at the given omega and normalized to one.
The output I has the same dimensions as the
input Emat.</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>Optional arguments: (varargin)</p>
<blockquote>
<div><dl>
<dt>‘-al[l]’  Requests that the calculated sqw be returned over</dt><dd><p>the whole of the domain of the input dataset. If not given, then
the function will be returned only at those points of the dataset
that contain data.
Applies only to input with no pixel information - it is ignored if
full sqw object.</p>
</dd>
<dt>‘-av[erage]’ Requests that the calculated sqw be computed for the</dt><dd><p>average values of h,k,l of the pixels in a bin, not for each
pixel individually. Reduces cost of expensive calculations.</p>
<blockquote>
<div><p>Applies only to the case of sqw object with pixel information - it is</p>
</div></blockquote>
<p>ignored if dnd type object.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id50">
<h3>Output:<a class="headerlink" href="#id50" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>wout        Output dataset or array of datasets</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.dispersion">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">dispersion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">dispreln</span></em>, <em class="sig-param"><span class="pre">pars</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.dispersion" title="Permalink to this definition"></a></dt>
<dd><p>Calculate dispersion relation for dataset or array of datasets.</p>
<p>New behaviour: Always returns appropriate dnd object. May be modified in
a future.</p>
<p>If the input contains array of sqw objects, the objects need to have the
same number of dimensions (may be relaxed if requested)</p>
<blockquote>
<div><p>&gt;&gt; wdisp = dispersion (win, dispreln, p)            % dispersion only
&gt;&gt; [wdisp,weight] = dispersion (win, dispreln, p)   % dispersion and spectral weight</p>
</div></blockquote>
<p>The output dataset (or array of data sets), wdisp, will retain only the Q axes, and
the signal array(s) will contain the values of energy along the Q axes. If the
dispersion relation returns the spectral weight, this will be placed in the error
array (actually the square of the spectral weight is put in the error array). In the
case when the dispersion has been calculated on a plane in momentum (i.e. wdisp
is IX_datset_2d) then the plot function ps2 (for plot_surface2)</p>
<blockquote>
<div><p>&gt;&gt; ps2(wdisp)</p>
</div></blockquote>
<p>will plot a surface with the z axis as energy and coloured according to the spectral
weight.</p>
<p>The dispersion relation is calculated at the bin centres (that is, the individual pixel
information in a sqw input object is not used).</p>
<p>If the function that calculates dispersion relations produces more than one
branch, then in the case of a single input dataset the output will be an array
of datasets, one for each branch. If the input is an array of datasets, then only
the first dispersion branch will be returned, so there is one output dataset per
input dataset.</p>
<section id="id51">
<h3>Input:<a class="headerlink" href="#id51" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl>
<dt>win         Dataset that provides the axes and points for the calculation</dt><dd><blockquote>
<div><p>If one of the plot axes is energy transfer, then the output dataset</p>
</div></blockquote>
<p>will have dimensionality one less than the input dataset</p>
</dd>
<dt>dispreln    Handle to function that calculates the dispersion relation w(Q)</dt><dd><dl>
<dt>Must have form:</dt><dd><blockquote>
<div><p>[w,s] = dispreln (qh,qk,ql,p)</p>
</div></blockquote>
<dl class="simple">
<dt>where</dt><dd><dl class="simple">
<dt>qh,qk,ql    Arrays containing the coordinates of a set of points</dt><dd><p>in reciprocal lattice units</p>
</dd>
<dt>p           Vector of parameters needed by dispersion function</dt><dd><p>e.g. [A,js,gam] as intensity, exchange, lifetime</p>
</dd>
<dt>w           Array of corresponding energies, or, if more than</dt><dd><p>one dispersion relation, a cell array of arrays.</p>
</dd>
<dt>s           Array of spectral weights, or, if more than</dt><dd><p>one dispersion relation, a cell array of arrays.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>More general form is:</dt><dd><blockquote>
<div><p>[w,s] = dispreln (qh,qk,ql,p,c1,c2,..)</p>
</div></blockquote>
<dl class="simple">
<dt>where</dt><dd><dl class="simple">
<dt>p           Typically a vector of parameters that we might want</dt><dd><p>to fit in a least-squares algorithm</p>
</dd>
<dt>c1,c2,…   Other constant parameters e.g. file name for look-up</dt><dd><p>table.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>p           Arguments needed by the function. Most commonly, a vector of parameter</dt><dd><p>values e.g. [A,js,gam] as intensity, exchange, lifetime. If a more general
set of parameters is required by the function, then
package these into a cell array and pass that as pars. In the example
above then pars = {p, c1, c2, …}</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id52">
<h3>Output:<a class="headerlink" href="#id52" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl>
<dt>wdisp       Output dataset or array of datasets of the same type as the input argument.</dt><dd><blockquote>
<div><p>The output dataset (or array of data sets) will retain only the Q axes, the</p>
</div></blockquote>
<p>the signal array(s) will contain the values of energy along the Q axes, and
the error array will contain the square of the spectral weight.</p>
<blockquote>
<div><p>If the function that calculates dispersion relations produces more than one</p>
</div></blockquote>
<p>branch, then in the case of a single input dataset the output will be an array
of datasets, one for each branch. If the input is an array of datasets, then only
the first dispersion branch will be returned, so there is one output dataset per
input dataset.</p>
</dd>
<dt>weight      Mirror output: the signal is the spectral weight, and the error array</dt><dd><p>contains the square of the frequency.</p>
</dd>
<dt>e.g.        If win is a 2D dataset with Q and E axes, then wdisp is a 1D dataset</dt><dd><p>with just the Q axis</p>
</dd>
</dl>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.equal_to_tol">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">equal_to_tol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em>, <em class="sig-param"><span class="pre">w2</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.equal_to_tol" title="Permalink to this definition"></a></dt>
<dd><p>Check if two sqw objects are equal to a given tolerance</p>
<blockquote>
<div><p>&gt;&gt; ok = equal_to_tol (a, b)
&gt;&gt; ok = equal_to_tol (a, b, tol)
&gt;&gt; ok = equal_to_tol (…, keyword1, val1, keyword2, val2,…)
&gt;&gt; [ok, mess] = equal_to_tol (…)</p>
</div></blockquote>
<dl class="simple">
<dt>Class specific version of the generic equal_to_tol that by default</dt><dd><ol class="arabic simple">
<li><p>assumes NaN are equivalent (see option ‘nan_equal’), and</p></li>
<li><p>ignores the order of pixels within a bin as the order is irrelevant
(change the default with option ‘reorder’)</p></li>
</ol>
</dd>
</dl>
<p>In addition, it is possible to check the contents of just a random
fraction of non-empty bins (see option ‘fraction’) in order to speed up
the comparison of large objects.</p>
<section id="id53">
<h3>Input:<a class="headerlink" href="#id53" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w1,w2   Test objects (scalar objects, or arrays of objects with same sizes)</p>
<dl>
<dt>tol     Tolerance criterion for numeric arrays (Default: [0,0] i.e. equality)</dt><dd><dl class="simple">
<dt>It has the form: [abstol, reltol] where</dt><dd><p>abstol     absolute tolerance (&gt;=0; if =0 equality required)
reltol     relative tolerance (&gt;=0; if =0 equality required)</p>
</dd>
</dl>
<p>If either criterion is satified then equality within tolerance
is accepted.</p>
<blockquote>
<div><dl class="simple">
<dt>Examples:</dt><dd><p>[1e-4, 1e-6]    absolute 1e-4 or relative 1e-6 required
[1e-4, 0]       absolute 1e-4 required
[0, 1e-6]       relative 1e-6 required
[0, 0]          equality required
0               equivalent to [0,0]</p>
</dd>
</dl>
</div></blockquote>
<p>For backwards compatibility, a scalar tolerance can be given
where the sign determines absolute or relative tolerance</p>
<blockquote>
<div><blockquote>
<div><p>+ve : absolute tolerance  abserr = abs(a-b)
-ve : relative tolerance  relerr = abs(a-b)/max(abs(a),abs(b))</p>
</div></blockquote>
<dl class="simple">
<dt>Examples:</dt><dd><p>1e-4            absolute tolerance, equivalent to [1e-4, 0]
-1e-6           relative tolerance, equivalent to [0, 1e-6]</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>[To apply an absolute as well as a relative tolerance with a</dt><dd><p>scalar negative value, set the value of the legacy keyword</p>
</dd>
</dl>
<p>‘min_denominator’ (see below)]</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>Valid keywords are:</dt><dd><p>‘nan_equal’      Treat NaNs as equal (true or false; default=true)</p>
<dl>
<dt>‘ignore_str’     Ignore the length and content of strings or cell arrays</dt><dd><p>of strings (true or false; default=false)</p>
</dd>
<dt>‘reorder’        Ignore the order of pixels within each bin</dt><dd><dl class="simple">
<dt>(true or false; default=true)</dt><dd><p>Only applies if sqw-type object</p>
</dd>
</dl>
</dd>
<dt>‘fraction’       Compare pixels in only a fraction of the non-empty bins</dt><dd><dl class="simple">
<dt>(0&lt;= fracton &lt;= 1; default=1 i.e. test all bins)</dt><dd><p>Only applies if sqw-type object</p>
</dd>
</dl>
</dd>
<dt>‘-ignore_date’   (provided without additional values, so its presence in</dt><dd><blockquote>
<div><blockquote>
<div><p>the sequence of keywords means true). If provided,
ignore file creation date stored in main header.</p>
</div></blockquote>
<p>The reorder and fraction options are available because the order of the</p>
</div></blockquote>
<p>pixels within the pix array for a given bin is unimportant. Reordering
takes time, however, so the option to test on a few bins is given.</p>
</dd>
</dl>
</dd>
</dl>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.exp">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.exp" title="Permalink to this definition"></a></dt>
<dd><p>Implements exp(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = exp(w1)</p>
</div></blockquote>
<section id="id54">
<h3>Input:<a class="headerlink" href="#id54" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id55">
<h3>Output:<a class="headerlink" href="#id55" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.func_eval">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">func_eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">func_handle</span></em>, <em class="sig-param"><span class="pre">pars</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.func_eval" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate a function at the plotting bin centres of sqw object or array
of sqw objects
Syntax:</p>
<blockquote>
<div><p>&gt;&gt; wout = func_eval (win, func_handle, pars)
&gt;&gt; wout = func_eval (win, func_handle, pars, [‘all’])
&gt;&gt; wout = func_eval (win, func_handle, pars, ‘outfile’, ‘output.sqw’)</p>
</div></blockquote>
<p>If function is called on sqw-type object (i.e. has pixels), the pixels’
signal is also modified and evaluated</p>
<section id="id56">
<h3>Input:<a class="headerlink" href="#id56" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl>
<dt>win         Dataset or array of datasets; the function will be evaluated</dt><dd><p>at the bin centres along the plot axes</p>
</dd>
<dt>func_handle Handle to the function to be evaluated at the bin centres</dt><dd><dl class="simple">
<dt>Must have form:</dt><dd><p>y = my_function (x1,x2,… ,xn,pars)</p>
</dd>
<dt>or, more generally:</dt><dd><p>y = my_function (x1,x2,… ,xn,pars,c1,c2,…)</p>
</dd>
</dl>
<ul class="simple">
<li><p>x1,x2,.xn Arrays of x coordinates along each of the n dimensions</p></li>
<li><p>pars      Parameters needed by the function</p></li>
<li><dl class="simple">
<dt>c1,c2,… Any further arguments needed by the function e.g.</dt><dd><p>they could be the filenames of lookup tables for
resolution effects)</p>
</dd>
</dl>
</li>
</ul>
<dl class="simple">
<dt>e.g. y=gauss2d(x1,x2,[ht,x0,sig])</dt><dd><p>y=gauss4d(x1,x2,x3,x4,[ht,x1_0,x2_0,x3_0,x4_0,sig1,sig2,sig3,sig4])</p>
</dd>
</dl>
</dd>
<dt>pars        Arguments needed by the function.</dt><dd><ul class="simple">
<li><p>Most commonly just a numeric array of parameters</p></li>
<li><p>If a more general set of parameters is needed by the function, then
wrap as a cell array {pars, c1, c2, …}</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">keyword outfile     If present, the output of func_eval will be written to the file</dt>
<dd class="field-odd"><p>of the given name/path.
If numel(win) &gt; 1, outfile must be omitted or a cell array of
file paths with equal number of elements as win.</p>
</dd>
</dl>
<dl>
<dt>Additional allowed options:</dt><dd><dl>
<dt>‘all’      Requests that the calculated function be returned over</dt><dd><p>the whole of the domain of the input dataset. If not given, then
the function will be returned only at those points of the dataset
that contain data.</p>
<blockquote>
<div><p>Applies only to input with no pixel information - this option is ignored if</p>
</div></blockquote>
<p>the input is a full sqw object.</p>
</dd>
</dl>
</dd>
</dl>
</section>
<section id="id57">
<h3>Output:<a class="headerlink" href="#id57" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>wout        Output objects or array of objects</p>
</div></blockquote>
<dl>
<dt>e.g.</dt><dd><p>&gt;&gt; wout = func_eval (w, &#64;gauss4d, [ht,x1_0,x2_0,x3_0,x4_0,sig1,sig2,sig3,sig4])</p>
<dl class="simple">
<dt>where the function gauss appears on the matlab path</dt><dd><p>function y = gauss4d (x1, x2, x3, x4, pars)
y = (pars(1)/(sig*sqrt(2*pi))) * …</p>
</dd>
</dl>
</dd>
</dl>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.log">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.log" title="Permalink to this definition"></a></dt>
<dd><p>Implements log(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = log(w1)</p>
</div></blockquote>
<section id="id58">
<h3>Input:<a class="headerlink" href="#id58" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id59">
<h3>Output:<a class="headerlink" href="#id59" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.log10">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">log10</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.log10" title="Permalink to this definition"></a></dt>
<dd><p>Implements log10(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = log10(w1)</p>
</div></blockquote>
<section id="id60">
<h3>Input:<a class="headerlink" href="#id60" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id61">
<h3>Output:<a class="headerlink" href="#id61" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.mask_points">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">mask_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.mask_points" title="Permalink to this definition"></a></dt>
<dd><p>TODO: Does not look like this function should be here</p>
<p>Determine the points to keep on the basis of ranges and mask array.</p>
<blockquote>
<div><p>&gt;&gt; sel = mask_points (win, ‘keep’, xkeep, ‘remove’, xremove, ‘mask’, mask)</p>
</div></blockquote>
<p>or any selection (in any order) of the keyword-argument pairs e.g.</p>
<blockquote>
<div><p>&gt;&gt; sel = mask_points (win, ‘mask’, mask, ‘remove’, xremove)</p>
</div></blockquote>
<section id="id62">
<h3>Input:<a class="headerlink" href="#id62" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>win     Input sqw object</p>
<dl>
<dt>xkeep   Ranges of display axes to retain for fitting. A range is specified by an array</dt><dd><p>of numbers which define a hypercube.
For example in case of two dimensions:</p>
<blockquote>
<div><p>[xlo, xhi, ylo, yhi]</p>
</div></blockquote>
<dl>
<dt>or in the case of n-dimensions:</dt><dd><blockquote>
<div><p>[x1_lo, x1_hi, x2_lo, x2_hi,…, xn_lo, xn_hi]</p>
</div></blockquote>
<dl class="simple">
<dt>e.g. 1D: [50,70]</dt><dd><p>2D: [1,2,130,160]</p>
</dd>
</dl>
</dd>
<dt>More than one range can be defined in rows,</dt><dd><blockquote>
<div><p>[Range_1; Range_2; Range_3;…; Range_m]</p>
</div></blockquote>
<p>where each of the ranges are given in the format above.</p>
</dd>
</dl>
</dd>
</dl>
<p>xremove Ranges of display axes to remove from fitting.</p>
<dl>
<dt>mask    Mask array of same number of elements as data array: 1 to keep, 0 to remove</dt><dd><blockquote>
<div><p>Note: mask will be applied to the stored data array</p>
</div></blockquote>
<p>according as the projection axes, not the display axes.
Thus permuting the display axes does not alter the
effect of masking the data. The mask array works
consistently with the input required by the mask method.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id63">
<h3>Output:<a class="headerlink" href="#id63" title="Permalink to this heading"></a></h3>
<blockquote>
<div><blockquote>
<div><p>sel     Mask array of same shape as <a href="#id115"><span class="problematic" id="id116">data_</span></a>. true for bins to keep, false to discard.</p>
</div></blockquote>
<p>Advanced use: in addition the following two arguments, if present, suppress failure or the
display of informational messges. Instead, the messages are returned to be used as desired.</p>
<blockquote>
<div><p>ok      =true if worked, =false if error</p>
<p>mess    messages: if ok=true then informational or warning, if ok=false then the error message</p>
</div></blockquote>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.minus">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">minus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em>, <em class="sig-param"><span class="pre">w2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.minus" title="Permalink to this definition"></a></dt>
<dd><p>Implements w1 - w2 for objects</p>
<blockquote>
<div><p>&gt;&gt; w = w1 - w2</p>
</div></blockquote>
<section id="id64">
<h3>Input:<a class="headerlink" href="#id64" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl>
<dt>w1, w2      Objects on which the binary operation is to be performed.</dt><dd><p>One of these can be a Matlab double (i.e. double precision)
array, in which case the variance array is taken to be zero.</p>
<p>If w1, w2 are scalar objects with the same signal array sizes:
- The operation is performed element-by-element.</p>
<p>If one of w1 or w2 is a double array (and the other is a
scalar object):
- If a scalar, apply to each element of the object signal.
- If it is an array of the same size as the object signal</p>
<blockquote>
<div><p>array, apply the operation element by element.</p>
</div></blockquote>
<p>If one or both of w1 and w2 are arrays of objects:
- If objects have same array sizes, the binary operation is</p>
<blockquote>
<div><p>applied object element-by-object element.</p>
</div></blockquote>
<ul class="simple">
<li><p>If one of the objects is scalar (i.e. only one object),</p></li>
</ul>
<blockquote>
<div><p>then it is applied by the binary operation to each object
in the other array.</p>
</div></blockquote>
<p>If one of w1, w2 is an array of objects and the other is a
double array:
- If the double is a scalar, it is applied to every object</p>
<blockquote>
<div><p>in the array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with the same size as the object</p></li>
</ul>
<blockquote>
<div><p>array, then each element is applied as a scalar to the
corresponding object in the object array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with larger size than the object</p></li>
</ul>
<blockquote>
<div><p>array, then the array is resolved into a stack of arrays,
where the stack has the same size as the object array, and
the each array in the stack is applied to the corresponding
object in the object array. [Note that for this operation
to be valid, each object must have the same signal array
size.]</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id65">
<h3>Output:<a class="headerlink" href="#id65" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.mldivide">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">mldivide</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em>, <em class="sig-param"><span class="pre">w2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.mldivide" title="Permalink to this definition"></a></dt>
<dd><p>Implements w1 w2 for objects</p>
<blockquote>
<div><p>&gt;&gt; w = w1 w2</p>
</div></blockquote>
<section id="id66">
<h3>Input:<a class="headerlink" href="#id66" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl>
<dt>w1, w2      Objects on which the binary operation is to be performed.</dt><dd><p>One of these can be a Matlab double (i.e. double precision)
array, in which case the variance array is taken to be zero.</p>
<p>If w1, w2 are scalar objects with the same signal array sizes:
- The operation is performed element-by-element.</p>
<p>If one of w1 or w2 is a double array (and the other is a
scalar object):
- If a scalar, apply to each element of the object signal.
- If it is an array of the same size as the object signal</p>
<blockquote>
<div><p>array, apply the operation element by element.</p>
</div></blockquote>
<p>If one or both of w1 and w2 are arrays of objects:
- If objects have same array sizes, the binary operation is</p>
<blockquote>
<div><p>applied object element-by-object element.</p>
</div></blockquote>
<ul class="simple">
<li><p>If one of the objects is scalar (i.e. only one object),</p></li>
</ul>
<blockquote>
<div><p>then it is applied by the binary operation to each object
in the other array.</p>
</div></blockquote>
<p>If one of w1, w2 is an array of objects and the other is a
double array:
- If the double is a scalar, it is applied to every object</p>
<blockquote>
<div><p>in the array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with the same size as the object</p></li>
</ul>
<blockquote>
<div><p>array, then each element is applied as a scalar to the
corresponding object in the object array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with larger size than the object</p></li>
</ul>
<blockquote>
<div><p>array, then the array is resolved into a stack of arrays,
where the stack has the same size as the object array, and
the each array in the stack is applied to the corresponding
object in the object array. [Note that for this operation
to be valid, each object must have the same signal array
size.]</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id67">
<h3>Output:<a class="headerlink" href="#id67" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.mpower">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">mpower</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em>, <em class="sig-param"><span class="pre">w2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.mpower" title="Permalink to this definition"></a></dt>
<dd><p>Implements w1 ^ w2 for objects</p>
<blockquote>
<div><p>&gt;&gt; w = w1 ^ w2</p>
</div></blockquote>
<section id="id68">
<h3>Input:<a class="headerlink" href="#id68" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl>
<dt>w1, w2      Objects on which the binary operation is to be performed.</dt><dd><p>One of these can be a Matlab double (i.e. double precision)
array, in which case the variance array is taken to be zero.</p>
<p>If w1, w2 are scalar objects with the same signal array sizes:
- The operation is performed element-by-element.</p>
<p>If one of w1 or w2 is a double array (and the other is a
scalar object):
- If a scalar, apply to each element of the object signal.
- If it is an array of the same size as the object signal</p>
<blockquote>
<div><p>array, apply the operation element by element.</p>
</div></blockquote>
<p>If one or both of w1 and w2 are arrays of objects:
- If objects have same array sizes, the binary operation is</p>
<blockquote>
<div><p>applied object element-by-object element.</p>
</div></blockquote>
<ul class="simple">
<li><p>If one of the objects is scalar (i.e. only one object),</p></li>
</ul>
<blockquote>
<div><p>then it is applied by the binary operation to each object
in the other array.</p>
</div></blockquote>
<p>If one of w1, w2 is an array of objects and the other is a
double array:
- If the double is a scalar, it is applied to every object</p>
<blockquote>
<div><p>in the array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with the same size as the object</p></li>
</ul>
<blockquote>
<div><p>array, then each element is applied as a scalar to the
corresponding object in the object array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with larger size than the object</p></li>
</ul>
<blockquote>
<div><p>array, then the array is resolved into a stack of arrays,
where the stack has the same size as the object array, and
the each array in the stack is applied to the corresponding
object in the object array. [Note that for this operation
to be valid, each object must have the same signal array
size.]</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id69">
<h3>Output:<a class="headerlink" href="#id69" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.mrdivide">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">mrdivide</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em>, <em class="sig-param"><span class="pre">w2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.mrdivide" title="Permalink to this definition"></a></dt>
<dd><p>Implements w1 / w2 for objects</p>
<blockquote>
<div><p>&gt;&gt; w = w1 / w2</p>
</div></blockquote>
<section id="id70">
<h3>Input:<a class="headerlink" href="#id70" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl>
<dt>w1, w2      Objects on which the binary operation is to be performed.</dt><dd><p>One of these can be a Matlab double (i.e. double precision)
array, in which case the variance array is taken to be zero.</p>
<p>If w1, w2 are scalar objects with the same signal array sizes:
- The operation is performed element-by-element.</p>
<p>If one of w1 or w2 is a double array (and the other is a
scalar object):
- If a scalar, apply to each element of the object signal.
- If it is an array of the same size as the object signal</p>
<blockquote>
<div><p>array, apply the operation element by element.</p>
</div></blockquote>
<p>If one or both of w1 and w2 are arrays of objects:
- If objects have same array sizes, the binary operation is</p>
<blockquote>
<div><p>applied object element-by-object element.</p>
</div></blockquote>
<ul class="simple">
<li><p>If one of the objects is scalar (i.e. only one object),</p></li>
</ul>
<blockquote>
<div><p>then it is applied by the binary operation to each object
in the other array.</p>
</div></blockquote>
<p>If one of w1, w2 is an array of objects and the other is a
double array:
- If the double is a scalar, it is applied to every object</p>
<blockquote>
<div><p>in the array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with the same size as the object</p></li>
</ul>
<blockquote>
<div><p>array, then each element is applied as a scalar to the
corresponding object in the object array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with larger size than the object</p></li>
</ul>
<blockquote>
<div><p>array, then the array is resolved into a stack of arrays,
where the stack has the same size as the object array, and
the each array in the stack is applied to the corresponding
object in the object array. [Note that for this operation
to be valid, each object must have the same signal array
size.]</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id71">
<h3>Output:<a class="headerlink" href="#id71" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.mtimes">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">mtimes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em>, <em class="sig-param"><span class="pre">w2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.mtimes" title="Permalink to this definition"></a></dt>
<dd><p>Implements w1 * w2 for objects</p>
<blockquote>
<div><p>&gt;&gt; w = w1 * w2</p>
</div></blockquote>
<section id="id72">
<h3>Input:<a class="headerlink" href="#id72" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl>
<dt>w1, w2      Objects on which the binary operation is to be performed.</dt><dd><p>One of these can be a Matlab double (i.e. double precision)
array, in which case the variance array is taken to be zero.</p>
<p>If w1, w2 are scalar objects with the same signal array sizes:
- The operation is performed element-by-element.</p>
<p>If one of w1 or w2 is a double array (and the other is a
scalar object):
- If a scalar, apply to each element of the object signal.
- If it is an array of the same size as the object signal</p>
<blockquote>
<div><p>array, apply the operation element by element.</p>
</div></blockquote>
<p>If one or both of w1 and w2 are arrays of objects:
- If objects have same array sizes, the binary operation is</p>
<blockquote>
<div><p>applied object element-by-object element.</p>
</div></blockquote>
<ul class="simple">
<li><p>If one of the objects is scalar (i.e. only one object),</p></li>
</ul>
<blockquote>
<div><p>then it is applied by the binary operation to each object
in the other array.</p>
</div></blockquote>
<p>If one of w1, w2 is an array of objects and the other is a
double array:
- If the double is a scalar, it is applied to every object</p>
<blockquote>
<div><p>in the array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with the same size as the object</p></li>
</ul>
<blockquote>
<div><p>array, then each element is applied as a scalar to the
corresponding object in the object array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with larger size than the object</p></li>
</ul>
<blockquote>
<div><p>array, then the array is resolved into a stack of arrays,
where the stack has the same size as the object array, and
the each array in the stack is applied to the corresponding
object in the object array. [Note that for this operation
to be valid, each object must have the same signal array
size.]</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id73">
<h3>Output:<a class="headerlink" href="#id73" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.multifit_func">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">multifit_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.multifit_func" title="Permalink to this definition"></a></dt>
<dd><p>Simultaneously fit function(s) to one or more sqw objects</p>
<blockquote>
<div><blockquote>
<div><p>&gt;&gt; myobj = multifit_func (w1, w2, …)      % w1, w2 objects or arrays of objects</p>
</div></blockquote>
<p>This creates a fitting object of class mfclass_Horace with the provided data,
which can then be manipulated to add further data, set the fitting
functions, initial parameter values etc. and fit or simulate the data.
For details about how to do this  &lt;a href=”matlab:help(‘mfclass_Horace’);”&gt;Click here&lt;/a&gt;</p>
<p>For example:</p>
<blockquote>
<div><dl class="simple">
<dt>&gt;&gt; myobj = multifit_func (w1, w2, …); % set the data</dt><dd><p>:</p>
</dd>
</dl>
<p>&gt;&gt; myobj = myobj.set_fun (&#64;function_name, pars);  % set forgraound function(s)
&gt;&gt; myobj = myobj.set_bfun (&#64;function_name, pars); % set background function(s)</p>
<blockquote>
<div><p>:</p>
</div></blockquote>
<p>&gt;&gt; myobj = myobj.set_free (pfree);      % set which parameters are floating
&gt;&gt; myobj = myobj.set_bfree (bpfree);    % set which parameters are floating
&gt;&gt; [wfit,fitpars] = myobj.fit;          % perform fit</p>
</div></blockquote>
<p>This method fits function(s) of the plot axes for both the foreground and
the background function(s). The format of the fit functions depends on
the number of plot axes for each sqw object. For examples see:
&lt;a href=”matlab:edit(‘example_1d_function’);”&gt;example_1d_function&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_2d_function’);”&gt;example_2d_function&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_3d_function’);”&gt;example_3d_function&lt;/a&gt;</p>
<p>See also multifit_sqw multifit_sqw_sqw</p>
</div></blockquote>
<dl class="simple">
<dt>[Help for legacy use (2017 and earlier):</dt><dd><p>If you are still using the legacy version then it is strongly recommended
that you change to the new operation. Help for the legacy operation can
be &lt;a href=”matlab:help(‘sqw/multifit_legacy_func’);”&gt;found here&lt;/a&gt;]</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.multifit_sqw">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">multifit_sqw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.multifit_sqw" title="Permalink to this definition"></a></dt>
<dd><p>Simultaneously fit function(s) of S(Q,w)to one or more sqw objects</p>
<blockquote>
<div><blockquote>
<div><p>&gt;&gt; myobj = multifit_sqw (w1, w2, …)      % w1, w2 objects or arrays of objects</p>
</div></blockquote>
<p>This creates a fitting object of class mfclass_Horace_sqw with the provided data,
which can then be manipulated to add further data, set the fitting
functions, initial parameter values etc. and fit or simulate the data.
For details about how to do this  &lt;a href=”matlab:help(‘mfclass_Horace_sqw’);”&gt;Click here&lt;/a&gt;</p>
<p>For example:</p>
<blockquote>
<div><dl class="simple">
<dt>&gt;&gt; myobj = multifit_sqw (w1, w2, …); % set the data</dt><dd><p>:</p>
</dd>
</dl>
<p>&gt;&gt; myobj = myobj.set_fun (&#64;function_name, pars);  % set forgraound function(s)
&gt;&gt; myobj = myobj.set_bfun (&#64;function_name, pars); % set background function(s)</p>
<blockquote>
<div><p>:</p>
</div></blockquote>
<p>&gt;&gt; myobj = myobj.set_free (pfree);      % set which parameters are floating
&gt;&gt; myobj = myobj.set_bfree (bpfree);    % set which parameters are floating
&gt;&gt; [wfit,fitpars] = myobj.fit;          % perform fit</p>
</div></blockquote>
<p>This method fits model(s) for S(Q,w) as the foreground function(s), and
function(s) of the plot axes for the background function(s)</p>
<p>For the format of foreground fit functions:
&lt;a href=”matlab:edit(‘example_sqw_spin_waves’);”&gt;Damped spin waves&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_sqw_flat_mode’);”&gt;Dispersionless excitations&lt;/a&gt;</p>
<p>The format of the background fit functions depends on the number of plot
axes for each sqw object. For examples see:
&lt;a href=”matlab:edit(‘example_1d_function’);”&gt;example_1d_function&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_2d_function’);”&gt;example_2d_function&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_3d_function’);”&gt;example_3d_function&lt;/a&gt;</p>
<p>See also multifit multifit_sqw_sqw</p>
</div></blockquote>
<dl class="simple">
<dt>[Help for legacy use (2017 and earlier):</dt><dd><p>If you are still using the legacy version then it is strongly recommended
that you change to the new operation. Help for the legacy operation can
be &lt;a href=”matlab:help(‘sqw/multifit_legacy_sqw’);”&gt;found here&lt;/a&gt;]</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.multifit_sqw_sqw">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">multifit_sqw_sqw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.multifit_sqw_sqw" title="Permalink to this definition"></a></dt>
<dd><p>Simultaneously fit function(s) of S(Q,w)to one or more sqw objects</p>
<blockquote>
<div><blockquote>
<div><p>&gt;&gt; myobj = multifit_sqw_sqw (w1, w2, …)      % w1, w2 objects or arrays of objects</p>
</div></blockquote>
<p>This creates a fitting object of class mfclass_Horace_sqw_sqw with the provided data,
which can then be manipulated to add further data, set the fitting
functions, initial parameter values etc. and fit or simulate the data.
For details about how to do this  &lt;a href=”matlab:help(‘mfclass_Horace_sqw_sqw’);”&gt;Click here&lt;/a&gt;</p>
<p>For example:</p>
<blockquote>
<div><dl class="simple">
<dt>&gt;&gt; myobj = multifit_sqw_sqw (w1, w2, …); % set the data</dt><dd><p>:</p>
</dd>
</dl>
<p>&gt;&gt; myobj = myobj.set_fun (&#64;function_name, pars);  % set forgraound function(s)
&gt;&gt; myobj = myobj.set_bfun (&#64;function_name, pars); % set background function(s)</p>
<blockquote>
<div><p>:</p>
</div></blockquote>
<p>&gt;&gt; myobj = myobj.set_free (pfree);      % set which parameters are floating
&gt;&gt; myobj = myobj.set_bfree (bpfree);    % set which parameters are floating
&gt;&gt; [wfit,fitpars] = myobj.fit;          % perform fit</p>
</div></blockquote>
<p>This method fits function(s) of S(Q,w) as both the foreground and
the background function(s). For the format of the fit functions:
&lt;a href=”matlab:edit(‘example_sqw_spin_waves’);”&gt;Damped spin waves&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_sqw_flat_mode’);”&gt;Dispersionless excitations&lt;/a&gt;</p>
<p>See also multifit multifit_sqw</p>
</div></blockquote>
<dl class="simple">
<dt>[Help for legacy use (2017 and earlier):</dt><dd><p>If you are still using the legacy version then it is strongly recommended
that you change to the new operation. Help for the legacy operation can
be &lt;a href=”matlab:help(‘sqw/multifit_legacy_sqw_sqw’);”&gt;found here&lt;/a&gt;]</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.plus">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">plus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em>, <em class="sig-param"><span class="pre">w2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.plus" title="Permalink to this definition"></a></dt>
<dd><p>Implements w1 + w2 for objects</p>
<blockquote>
<div><p>&gt;&gt; w = w1 + w2</p>
</div></blockquote>
<section id="id74">
<h3>Input:<a class="headerlink" href="#id74" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl>
<dt>w1, w2      Objects on which the binary operation is to be performed.</dt><dd><p>One of these can be a Matlab double (i.e. double precision)
array, in which case the variance array is taken to be zero.</p>
<p>If w1, w2 are scalar objects with the same signal array sizes:
- The operation is performed element-by-element.</p>
<p>If one of w1 or w2 is a double array (and the other is a
scalar object):
- If a scalar, apply to each element of the object signal.
- If it is an array of the same size as the object signal</p>
<blockquote>
<div><p>array, apply the operation element by element.</p>
</div></blockquote>
<p>If one or both of w1 and w2 are arrays of objects:
- If objects have same array sizes, the binary operation is</p>
<blockquote>
<div><p>applied object element-by-object element.</p>
</div></blockquote>
<ul class="simple">
<li><p>If one of the objects is scalar (i.e. only one object),</p></li>
</ul>
<blockquote>
<div><p>then it is applied by the binary operation to each object
in the other array.</p>
</div></blockquote>
<p>If one of w1, w2 is an array of objects and the other is a
double array:
- If the double is a scalar, it is applied to every object</p>
<blockquote>
<div><p>in the array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with the same size as the object</p></li>
</ul>
<blockquote>
<div><p>array, then each element is applied as a scalar to the
corresponding object in the object array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with larger size than the object</p></li>
</ul>
<blockquote>
<div><p>array, then the array is resolved into a stack of arrays,
where the stack has the same size as the object array, and
the each array in the stack is applied to the corresponding
object in the object array. [Note that for this operation
to be valid, each object must have the same signal array
size.]</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id75">
<h3>Output:<a class="headerlink" href="#id75" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.save">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.save" title="Permalink to this definition"></a></dt>
<dd><p>Save a sqw object or array of sqw objects to file</p>
<blockquote>
<div><p>&gt;&gt; save (w)              % prompt for file
&gt;&gt; save (w, file)        % give file
&gt;&gt; save (w, file,loader) % save file using specific data loader</p>
<blockquote>
<div><p>(-update option, is provided, will be
ignored)</p>
</div></blockquote>
<dl class="simple">
<dt>&gt;&gt; save (w, file,[‘-parallel’<a href="#id76"><span class="problematic" id="id77">|</span></a>JobDispatcher])</dt><dd><p>combine file usging parallel algorithm.
Useful and would works only if (when) pix
value of sqw object data is set up to the
instance of pix_combine_info class,
containing information on the partial
tmp files, written by filebased gen_sqw or
cut algorithm</p>
</dd>
<dt>&gt;&gt; save (w, file,’-update’) % if the target file exist, update it to</dt><dd><p>latest format if this is possible. If
update is possible, pixels in file will not be
overwritten.</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>Input:</dt><dd><p>w       sqw object
file    [optional] File for output. if none given, then prompted for a file</p>
<p>Note that if w is an array of sqw objects then file must be a cell
array of filenames of the same size.</p>
</dd>
</dl>
<p>Optional output:
cl – running insance of parallel cluster, used to combine multiple tmp</p>
<blockquote>
<div><blockquote>
<div><p>files together if pix field of sqw object contains pix_combine_into
and -parallel option or parallel cluster itself are provided as
inpout. Empty in any other case</p>
</div></blockquote>
<p>TODO: currenlty empty. May reenable when parallel saving is
implemented properly</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.sec">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">sec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.sec" title="Permalink to this definition"></a></dt>
<dd><p>Implements sec(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = sec(w1)</p>
</div></blockquote>
<section id="id78">
<h3>Input:<a class="headerlink" href="#id78" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id79">
<h3>Output:<a class="headerlink" href="#id79" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.sech">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">sech</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.sech" title="Permalink to this definition"></a></dt>
<dd><p>Implements sech(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = sech(w1)</p>
</div></blockquote>
<section id="id80">
<h3>Input:<a class="headerlink" href="#id80" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id81">
<h3>Output:<a class="headerlink" href="#id81" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.sin">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">sin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.sin" title="Permalink to this definition"></a></dt>
<dd><p>Implements sin(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = sin(w1)</p>
</div></blockquote>
<section id="id82">
<h3>Input:<a class="headerlink" href="#id82" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id83">
<h3>Output:<a class="headerlink" href="#id83" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.sinh">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">sinh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.sinh" title="Permalink to this definition"></a></dt>
<dd><p>Implements sinh(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = sinh(w1)</p>
</div></blockquote>
<section id="id84">
<h3>Input:<a class="headerlink" href="#id84" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id85">
<h3>Output:<a class="headerlink" href="#id85" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.sqrt">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">sqrt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.sqrt" title="Permalink to this definition"></a></dt>
<dd><p>Implements sqrt(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = sqrt(w1)</p>
</div></blockquote>
<section id="id86">
<h3>Input:<a class="headerlink" href="#id86" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id87">
<h3>Output:<a class="headerlink" href="#id87" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.sqw_eval">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">sqw_eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">sqwfunc</span></em>, <em class="sig-param"><span class="pre">pars</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.sqw_eval" title="Permalink to this definition"></a></dt>
<dd><p>Calculate sqw for a model scattering function</p>
<blockquote>
<div><blockquote>
<div><p>&gt;&gt; wout = sqw_eval(win, sqwfunc, p)
&gt;&gt; wout = sqw_eval(___, ‘-all’)
&gt;&gt; wout = sqw_eval(___, ‘all’, true)
&gt;&gt; wout = sqw_eval(___, ‘-average’)
&gt;&gt; wout = sqw_eval(___, ‘average’, true)
&gt;&gt; sqw_eval(___, ‘outfile’, outfile)
&gt;&gt; wout = sqw_eval(___, ‘outfile’, outfile)
&gt;&gt; sqw_eval(__, ‘outfile’, outfile, ‘filebacked’, true)
&gt;&gt; wout = sqw_eval(__, ‘filebacked’, true)</p>
</div></blockquote>
<blockquote>
<div><dl>
<dt>win        Dataset (or array of datasets) that provides the axes and points</dt><dd><p>for the calculation</p>
</dd>
<dt>sqwfunc     Handle to function that calculates S(Q, w)</dt><dd><dl>
<dt>Most commonly used form is:</dt><dd><blockquote>
<div><p>weight = sqwfunc (qh, qk, ql, en, p)</p>
</div></blockquote>
<dl>
<dt>where</dt><dd><p>qh,qk,ql,en Arrays containing the coordinates of a set of points
p           Vector of parameters needed by dispersion function</p>
<blockquote>
<div><p>e.g. [A, js, gam] as intensity, exchange, lifetime</p>
</div></blockquote>
<p>weight      Array containing calculated spectral weight</p>
</dd>
</dl>
</dd>
<dt>More general form is:</dt><dd><blockquote>
<div><p>weight = sqwfunc (qh, qk, ql, en, p, c1, c2, ..)</p>
</div></blockquote>
<dl class="simple">
<dt>where</dt><dd><dl class="simple">
<dt>p           Typically a vector of parameters that we might want</dt><dd><p>to fit in a least-squares algorithm</p>
</dd>
<dt>c1, c2, …   Other constant parameters e.g. file name for look-up</dt><dd><p>table</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>pars       Arguments needed by the function. Most commonly, a vector of parameter</dt><dd><p>values e.g. [A, js, gam] as intensity, exchange, lifetime. If a more general
set of parameters is required by the function, then
package these into a cell array and pass that as pars. In the example
above then pars = {p, c1, c2, …}</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><dl>
<dt>outfile    If present, the outputs will be written to the file of the given</dt><dd><p>name/path.
If numel(win) &gt; 1, outfile must either be omitted or be a cell
array of file paths with equal number of elements as win.</p>
</dd>
<dt>all        If true, requests that the calculated sqw be returned over</dt><dd><p>the whole of the domain of the input dataset. If false, then
the function will be returned only at those points of the dataset
that contain <a href="#id117"><span class="problematic" id="id118">data_</span></a>.</p>
<blockquote>
<div><p>Applies only to input with no pixel information - it is ignored if</p>
</div></blockquote>
<p>full sqw object.
[default = false]</p>
</dd>
<dt>average    If true, requests that the calculated sqw be computed for the</dt><dd><p>average values of h, k, l of the pixels in a bin, not for each
pixel individually. Reduces cost of expensive calculations.
Applies only to the case of sqw object with pixel information
- it is ignored if dnd type object.
[default = false]</p>
</dd>
<dt>filebacked  If true, the result of the function will be saved to file and</dt><dd><p>the output will be a file path. If no <cite>outfile</cite> is specified,
a unique path within <cite>tempdir()</cite> will be generated.
Default is false.</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Note: all optional string input parameters can be truncated up to minimal</dt><dd><p>difference between them e.g. routine would accept ‘al’ and
‘av’, ‘ave’, ‘aver’ etc….</p>
</dd>
</dl>
<blockquote>
<div><dl class="simple">
<dt>wout        If <cite>filebacked</cite> is false, an sqw object or array of sqw objects.</dt><dd><p>If <cite>filebacked</cite> is true, a file path or cell array of file paths.
Output argument must be specified if <cite>outfile</cite> not given.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
</dd></dl>

<hr class="docutils" />
<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.sqw_eval_nopix">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">sqw_eval_nopix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">sqwfunc</span></em>, <em class="sig-param"><span class="pre">all_bins</span></em>, <em class="sig-param"><span class="pre">pars</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.sqw_eval_nopix" title="Permalink to this definition"></a></dt>
<dd><p>SQW_EVAL_NOPIX</p>
<blockquote>
<div><p>Helper function for sqw eval executed on a pixel-less object (i.e. DnD or SQW with no pixels
Called by <cite>sqw_eval_</cite> defined in sqw/DnDBase</p>
<blockquote>
<div><dl class="simple">
<dt>obj        Dataset (or array of datasets) that provides the axes and points</dt><dd><p>for the calculation</p>
</dd>
</dl>
<p>sqwfunc     Handle to function that calculates S(Q,w)
all_bins    Boolean flag wither to apply function to all bins or only those contaiing data
pars       Arguments needed by the function.</p>
</div></blockquote>
</div></blockquote>
</dd></dl>

<hr class="docutils" />
<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.tan">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">tan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.tan" title="Permalink to this definition"></a></dt>
<dd><p>Implements tan(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = tan(w1)</p>
</div></blockquote>
<section id="id88">
<h3>Input:<a class="headerlink" href="#id88" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id89">
<h3>Output:<a class="headerlink" href="#id89" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.tanh">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">tanh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.tanh" title="Permalink to this definition"></a></dt>
<dd><p>Implements tanh(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = tanh(w1)</p>
</div></blockquote>
<section id="id90">
<h3>Input:<a class="headerlink" href="#id90" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id91">
<h3>Output:<a class="headerlink" href="#id91" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.uminus">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">uminus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.uminus" title="Permalink to this definition"></a></dt>
<dd><p>Implements uminus(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = uminus(w1)</p>
</div></blockquote>
<section id="id92">
<h3>Input:<a class="headerlink" href="#id92" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id93">
<h3>Output:<a class="headerlink" href="#id93" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.uplus">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">uplus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.uplus" title="Permalink to this definition"></a></dt>
<dd><p>Implements uplus(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = uplus(w1)</p>
</div></blockquote>
<section id="id94">
<h3>Input:<a class="headerlink" href="#id94" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id95">
<h3>Output:<a class="headerlink" href="#id95" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

</section>
<section id="module-sqw.&#64;Experiment">
<span id="experiment-class"></span><h2><a class="toc-backref" href="#id113"><code class="docutils literal notranslate"><span class="pre">Experiment</span></code> class</a><a class="headerlink" href="#module-sqw.@Experiment" title="Permalink to this heading"></a></h2>
<dl class="mat class">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.Experiment">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sqw.&#64;Experiment.</span></span><span class="sig-name descname"><span class="pre">Experiment</span></span><a class="headerlink" href="#sqw.@Experiment.Experiment" title="Permalink to this definition"></a></dt>
<dd><p>EXPERIMENT Container object for all data describing the Experiment</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.change_crystal">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;Experiment.</span></span><span class="sig-name descname"><span class="pre">change_crystal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">alatt</span></em>, <em class="sig-param"><span class="pre">angdeg</span></em>, <em class="sig-param"><span class="pre">rlu_corr</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.change_crystal" title="Permalink to this definition"></a></dt>
<dd><dl>
<dt>Change fields in the experiment with correction related to change crystal</dt><dd><p>lattice parameters and orientation</p>
<blockquote>
<div><p>&gt;&gt; obj=change_crystal(obj,alatt,angdeg,rlu_corr)</p>
</div></blockquote>
</dd>
</dl>
<p>Change fields of Experiment as required</p>
</dd></dl>

</section>
<section id="module-sqw.PixelData.&#64;PixelData">
<span id="pixeldata-class"></span><h2><a class="toc-backref" href="#id114"><code class="docutils literal notranslate"><span class="pre">PixelData</span></code> class</a><a class="headerlink" href="#module-sqw.PixelData.@PixelData" title="Permalink to this heading"></a></h2>
<dl class="mat class">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sqw.PixelData.&#64;PixelData.</span></span><span class="sig-name descname"><span class="pre">PixelData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">arg</span></em>, <em class="sig-param"><span class="pre">mem_alloc</span></em>, <em class="sig-param"><span class="pre">upgrade</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData" title="Permalink to this definition"></a></dt>
<dd><p>PixelData Provides an interface for access to pixel data</p>
<blockquote>
<div><p>This class provides getters and setters for each data column in an SQW
pixel array. You can access the data using the attributes listed below,
using the get_data() method (to retrieve column data) or using the
get_pixels() method (retrieve row data).</p>
<p>Construct this class with an 9 x N array, a file path to an SQW object or
an instance of sqw_binfile_common.</p>
<p>&gt;&gt; pix_data = PixelData(data);
&gt;&gt; pix_data = PixelData(‘/path/to/sqw.sqw’);
&gt;&gt; pix_data = PixelData(‘/path/to/sqw.sqw’, mem_alloc);
&gt;&gt; pix_data = PixelData(faccess_obj);
&gt;&gt; pix_data = PixelData(faccess_obj, mem_alloc);</p>
<p>Constructing via a file or sqw_binfile_common will create a file-backed
data object. No pixel data will be loaded from the file on construction.
Data will be loaded when a getter is called e.g. pix_data.signal. Data will
be loaded in pages such that the data held in memory will not exceed the
size (in bytes) specified by private attribute <a href="#id119"><span class="problematic" id="id120">page_memory_size_</span></a> - this can
be set on construction (see mem_alloc above).</p>
<p>The file-backed operations work by loading “pages” of data into memory as
required. If editing pixels, to avoid losing changes, if a page has been
edited and the next page is then loaded, the “dirty” page will be written
to a tmp file. This class’s getters will then retrieve data from the tmp
file if that data is requested from the “dirty” page. Note that “dirty”
pages are written to tmp files as floats, but stored in memory as double.
This means data is truncated when moving pages, hence pixel data should not
be relied upon being accurate to double precision.</p>
</div></blockquote>
<p>Usage:</p>
<blockquote>
<div><blockquote>
<div><p>&gt;&gt; pix_data = PixelData(data)
&gt;&gt; signal = pix_data.signal;</p>
</div></blockquote>
<p>or equivalently:</p>
<blockquote>
<div><p>&gt;&gt; pix_data = PixelData();
&gt;&gt; pix_data.data = data;
&gt;&gt; signal = pix_data.get_data(‘signal’);</p>
</div></blockquote>
<p>To retrieve multiple fields of data, e.g. run_idx and energy_idx, for pixels 1 to 10:</p>
<blockquote>
<div><p>&gt;&gt; pix_data = PixelData(data);
&gt;&gt; signal = pix_data.get_data({‘run_idx’, ‘energy_idx’}, 1:10);</p>
</div></blockquote>
<p>To retrieve data for pixels 1, 4 and 10 (returning another PixelData object):</p>
<blockquote>
<div><p>&gt;&gt; pix_data = PixelData(data);
&gt;&gt; pixel_subset = pix_data.get_pixels([1, 4, 10])</p>
</div></blockquote>
<p>To sum the signal of a file-backed object where the page size is less than
amount of data in the file:</p>
<blockquote>
<div><p>&gt;&gt; pix = PixelData(‘my_data.sqw’)
&gt;&gt; signal_sum = 0;
&gt;&gt; while pix.has_more()
&gt;&gt;     signal_sum = signal_sum + pix.signal;
&gt;&gt;     pix.advance();
&gt;&gt; end</p>
</div></blockquote>
</div></blockquote>
<dl>
<dt>Properties:</dt><dd><dl class="simple">
<dt>u1, u2, u3     - The 1st, 2nd and 3rd dimensions of the Crystal</dt><dd><p>Cartesian coordinates in projection axes, units are per Angstrom (1 x n arrays)</p>
</dd>
</dl>
<p>dE             - The energy transfer value for each pixel in meV (1 x n array)
coordinates    - The coords in projection axes of the pixel data [u1, u2, u3, dE] (4 x n array)
q_coordinates  - The spacial coords in projection axes of the pixel data [u1, u2, u3] (3 x n array)
run_idx        - The run index the pixel originated from (1 x n array)
detector_idx   - The detector group number in the detector listing for the pixels (1 x n array)
energy_idx     - The energy bin numbers (1 x n array)
signal         - The signal array (1 x n array).
variance       - The variance on the signal array (variance i.e. error bar squared) (1 x n array)</p>
<p>num_pixels     - The number of pixels in the data block.
pix_range      - [2x4] array of the range of pixels coordinates in Crystal Cartesian coordinate system.</p>
<dl class="simple">
<dt>data           - The raw pixel data - usage of this attribute is discouraged, the structure</dt><dd><p>of the return value is not guaranteed.</p>
</dd>
</dl>
<p>page_size      - The number of pixels in the currently loaded page.</p>
</dd>
</dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.DATA_POINT_SIZE">
<span class="sig-name descname"><span class="pre">DATA_POINT_SIZE</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'8'</span></em><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.DATA_POINT_SIZE" title="Permalink to this definition"></a></dt>
<dd><p>num bytes in a double</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.DEFAULT_PAGE_SIZE">
<span class="sig-name descname"><span class="pre">DEFAULT_PAGE_SIZE</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'realmax'</span></em><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.DEFAULT_PAGE_SIZE" title="Permalink to this definition"></a></dt>
<dd><p>this gives no paging by default</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.PixelData">
<span class="sig-name descname"><span class="pre">PixelData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">arg</span></em>, <em class="sig-param"><span class="pre">mem_alloc</span></em>, <em class="sig-param"><span class="pre">upgrade</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.PixelData" title="Permalink to this definition"></a></dt>
<dd><dl>
<dt>Construct a PixelData object from the given data. Default</dt><dd><p>construction initialises the underlying data as an empty (9 x 0)
array.</p>
<blockquote>
<div><p>&gt;&gt; obj = PixelData(ones(9, 200))</p>
<p>&gt;&gt; obj = PixelData(200)  % initialise 200 pixels with underlying data set to zero</p>
<p>&gt;&gt; obj = PixelData(file_path)  % initialise pixel data from an sqw file</p>
<p>&gt;&gt; obj = PixelData(faccess_reader)  % initialise pixel data from an sqw file reader</p>
<p>&gt;&gt; obj = PixelData(faccess_reader, mem_alloc)  % set maximum memory allocation</p>
</div></blockquote>
</dd>
<dt>&gt;&gt; obj = PixelData(__,false) – not upgrade class averages</dt><dd><blockquote>
<div><p>(pix_range) for old file format, if these averages
are not stored in the file. Default – true. Pixel
averages are calculated on construction</p>
</div></blockquote>
<blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>arg    A 9 x n matrix, where each row corresponds to a pixel and</dt><dd><dl class="simple">
<dt>the columns correspond to the following:</dt><dd><p>col 1: u1
col 2: u2
col 3: u3
col 4: dE
col 5: run_idx
col 6: detector_idx
col 7: energy_idx
col 8: signal
col 9: variance</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>arg    An integer specifying the desired number of pixels. The underlying</dt><dd><p>data will be filled with zeros.</p>
</dd>
</dl>
<p>arg    A path to an SQW file.</p>
<p>arg    An instance of an sqw_binfile_common file reader.</p>
<dl class="simple">
<dt>mem_alloc    The maximum amount of memory allocated to hold pixel</dt><dd><p>data in bytes. If pixels cannot all be held in memory
at one time, they will be loaded from the file
(specified by ‘arg’) when they are required. This
argument does nothing if the class is constructed with
in-memory data. (Optional)</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.advance">
<span class="sig-name descname"><span class="pre">advance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.advance" title="Permalink to this definition"></a></dt>
<dd><p>Load the next page of pixel data from the file backing the object</p>
<p>This function will throw a PIXELDATA:advance error if attempting to
advance past the final page of data in the file.</p>
<p>This function does nothing if the pixel data is not file-backed.</p>
<blockquote>
<div><p>&gt;&gt; obj.advance()
&gt;&gt; obj.advance(‘nosave’, true)</p>
</div></blockquote>
<section id="inputs">
<h3>Inputs:<a class="headerlink" href="#inputs" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>nosave  Keyword argument. Set to true to discard changes to cache.</dt><dd><p>(default: false)</p>
</dd>
</dl>
</section>
<section id="outputs">
<h3>Outputs:<a class="headerlink" href="#outputs" title="Permalink to this heading"></a></h3>
<p>current_page_number  The new page and total number of pages advance will
walk through to complete the algorithm</p>
</section>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.base_page_size">
<span class="sig-name descname"><span class="pre">base_page_size</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.base_page_size" title="Permalink to this definition"></a></dt>
<dd><p>The number of pixels that can fit in one page of data</p>
</dd></dl>

<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.cat">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">cat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.cat" title="Permalink to this definition"></a></dt>
<dd><p>Concatenate the given PixelData objects’ pixels. This function performs
a straight-forward data concatenation.</p>
<blockquote>
<div><p>&gt;&gt; joined_pix = PixelData.cat(pix_data1, pix_data2);</p>
</div></blockquote>
<section id="id96">
<h3>Input:<a class="headerlink" href="#id96" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>varargin    A cell array of PixelData objects</p>
</div></blockquote>
</section>
<section id="id97">
<h3>Output:<a class="headerlink" href="#id97" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>obj         A PixelData object containing all the pixels in the inputted</dt><dd><p>PixelData objects</p>
</dd>
</dl>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.coordinates">
<span class="sig-name descname"><span class="pre">coordinates</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.coordinates" title="Permalink to this definition"></a></dt>
<dd><p>The coordinates of the pixels in the projection axes, i.e.: u1,</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.copy" title="Permalink to this definition"></a></dt>
<dd><p>Make an independent copy of this object
This method simply constructs a new PixelData instance by calling
the constructor with the input object as an argument. Because of
this, any properties that need to be explicitly copied must be
copied within this classes “copy-constructor”.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.dE">
<span class="sig-name descname"><span class="pre">dE</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.dE" title="Permalink to this definition"></a></dt>
<dd><p>The array of energy deltas of the pixels (1 x n array) [meV]</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.data">
<span class="sig-name descname"><span class="pre">data</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.data" title="Permalink to this definition"></a></dt>
<dd><p>The full raw pixel data block. Usage of this attribute exposes</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.delete">
<span class="sig-name descname"><span class="pre">delete</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.delete" title="Permalink to this definition"></a></dt>
<dd><p>Class destructor to delete any temporary files</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.detector_idx">
<span class="sig-name descname"><span class="pre">detector_idx</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.detector_idx" title="Permalink to this definition"></a></dt>
<dd><p>The detector group number in the detector listing for the pixels (1 x n array)</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.energy_idx">
<span class="sig-name descname"><span class="pre">energy_idx</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.energy_idx" title="Permalink to this definition"></a></dt>
<dd><p>The energy bin numbers (1 x n array)</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.file_path">
<span class="sig-name descname"><span class="pre">file_path</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.file_path" title="Permalink to this definition"></a></dt>
<dd><p>The file that the pixel data has been read from, empty if no file</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.has_more">
<span class="sig-name descname"><span class="pre">has_more</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.has_more" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if there are subsequent pixels stored in the file that
are not held in the current page</p>
<blockquote>
<div><p>&gt;&gt; has_more = pix.has_more();</p>
</div></blockquote>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.is_filebacked">
<span class="sig-name descname"><span class="pre">is_filebacked</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.is_filebacked" title="Permalink to this definition"></a></dt>
<dd><p>Return true if the pixel data is backed by a file or files. Returns
false if all pixel data is held in memory</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.isempty">
<span class="sig-name descname"><span class="pre">isempty</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.isempty" title="Permalink to this definition"></a></dt>
<dd><p>Return true if the PixelData object holds no pixel data</p>
</dd></dl>

<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.loadobj">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">loadobj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">S</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.loadobj" title="Permalink to this definition"></a></dt>
<dd><p>Load a PixelData object from a .mat file</p>
<dl>
<dt>&gt;&gt; obj = PixelData.loadobj(S)</dt><dd><blockquote>
<div><dl class="simple">
<dt>S       A data, produeced by saveobj operation and stored</dt><dd><p>in .mat file</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>obj     An instance of PixelData object or array of objects</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.move_to_first_page">
<span class="sig-name descname"><span class="pre">move_to_first_page</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.move_to_first_page" title="Permalink to this definition"></a></dt>
<dd><p>Reset the object to point to the first page of pixel data in the file
and clear the current cache</p>
<blockquote>
<div><p>This function does nothing if pixels are not file-backed.</p>
</div></blockquote>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.num_pixels">
<span class="sig-name descname"><span class="pre">num_pixels</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.num_pixels" title="Permalink to this definition"></a></dt>
<dd><p>The number of pixels in the data block</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.page_size">
<span class="sig-name descname"><span class="pre">page_size</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.page_size" title="Permalink to this definition"></a></dt>
<dd><p>The number of pixels in the current page</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.pix_range">
<span class="sig-name descname"><span class="pre">pix_range</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.pix_range" title="Permalink to this definition"></a></dt>
<dd><p>The range of pixels coordinates in Crystal Cartesian</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.q_coordinates">
<span class="sig-name descname"><span class="pre">q_coordinates</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.q_coordinates" title="Permalink to this definition"></a></dt>
<dd><p>The spatial dimensions of the Crystal Cartesian</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.run_idx">
<span class="sig-name descname"><span class="pre">run_idx</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.run_idx" title="Permalink to this definition"></a></dt>
<dd><p>The run index the pixel originated from (1 x n array)</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.set_range">
<span class="sig-name descname"><span class="pre">set_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">pix_range</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.set_range" title="Permalink to this definition"></a></dt>
<dd><p>Function allows to set the pixels range (min/max values of
pixels coordinates)</p>
<p>Use with caution!!! As this is performance function,
no checks that the set range is the
correct range for pixels, holded by the class are
performed, while subsequent algorithms may rely on pix range
to be correct. A out-of memory assignment can occur during
rebinning if the range is smaller, then the actual range.</p>
<p>Necessary to set up the pixel range when filebased
pixels are modified by algorithm and correct range
calculations are expensive</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.signal">
<span class="sig-name descname"><span class="pre">signal</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.signal" title="Permalink to this definition"></a></dt>
<dd><p>The signal array (1 x n array)</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.struct">
<span class="sig-name descname"><span class="pre">struct</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.struct" title="Permalink to this definition"></a></dt>
<dd><p>convert object into saveable and serializable structure</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.u1">
<span class="sig-name descname"><span class="pre">u1</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.u1" title="Permalink to this definition"></a></dt>
<dd><p>The 1st dimension of the Crystal Cartesian orientation (1 x n array) [A^-1]</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.u2">
<span class="sig-name descname"><span class="pre">u2</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.u2" title="Permalink to this definition"></a></dt>
<dd><p>The 2nd dimension of the Crystal Cartesian orientation (1 x n array) [A^-1]</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.u3">
<span class="sig-name descname"><span class="pre">u3</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.u3" title="Permalink to this definition"></a></dt>
<dd><p>The 3rd dimension of the Crystal Cartesian orientation (1 x n array) [A^-1]</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.variance">
<span class="sig-name descname"><span class="pre">variance</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.variance" title="Permalink to this definition"></a></dt>
<dd><p>The variance on the signal array</p>
</dd></dl>

</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.append">
<span class="sig-prename descclassname"><span class="pre">sqw.PixelData.&#64;PixelData.</span></span><span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">pix</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.append" title="Permalink to this definition"></a></dt>
<dd><p>Join the pixels in the given PixelData object to the end of this
object.</p>
<p>The pixels to append must all be in memory and you cannot append pixels if
the inputted PixelData object has more pixels than are allowed in a single
page.</p>
<section id="id98">
<h3>Input<a class="headerlink" href="#id98" title="Permalink to this heading"></a></h3>
<p>pix    A PixelData object containing the pixels to append</p>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.compute_bin_data">
<span class="sig-prename descclassname"><span class="pre">sqw.PixelData.&#64;PixelData.</span></span><span class="sig-name descname"><span class="pre">compute_bin_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">npix</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.compute_bin_data" title="Permalink to this definition"></a></dt>
<dd><p>Compute the mean signal and variance given the number of contributing
pixels for each bin
Returns empty arrays if obj contains no pixels.</p>
<blockquote>
<div><p>&gt;&gt; [mean_signal, mean_variance] = compute_bin_data(obj, npix)</p>
</div></blockquote>
<section id="id99">
<h3>Input<a class="headerlink" href="#id99" title="Permalink to this heading"></a></h3>
<p>npix   The number of contributing pixels to each bin of the plot axes</p>
</section>
<section id="id100">
<h3>Output<a class="headerlink" href="#id100" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>mean_signal     The average signal for each plot axis bin.</dt><dd><p>size(mean_signal) = size(npix)</p>
</dd>
<dt>mean_variance   The average variance for each plot axis bin.</dt><dd><p>size(mean_variance) = size(npix)</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.do_binary_op">
<span class="sig-prename descclassname"><span class="pre">sqw.PixelData.&#64;PixelData.</span></span><span class="sig-name descname"><span class="pre">do_binary_op</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">operand</span></em>, <em class="sig-param"><span class="pre">binary_op</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.do_binary_op" title="Permalink to this definition"></a></dt>
<dd><dl>
<dt>DO_BINARY_OP perform a binary operation between this object and the given</dt><dd><p>operand</p>
<p>&gt;&gt; pix_diff = obj.do_binary_op(other_pix, &#64;minus_single, ‘flip’, true)</p>
<p>&gt;&gt; pix_sum = obj.do_binary_op(signal_array, &#64;plus_single, ‘npix’, npix)</p>
<p>&gt;&gt; pix_sum = obj.do_binary_op(signal_array, &#64;plus_single, ‘npix’, npix, ‘flip’, true)</p>
</dd>
</dl>
<section id="id101">
<h3>Input<a class="headerlink" href="#id101" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>operand    The second operand to use in the binary operation.</dt><dd><dl class="simple">
<dt>The operand must have one of the following types:</dt><dd><ul class="simple">
<li><p>scalar double</p></li>
<li><p>double array, the size of the array must be equal to
obj.num_pixels</p></li>
<li><p>object with fields ‘s’ and ‘e’ (e.g. dnd or sigvar)</p></li>
<li><p>another PixelData object with obj.num_pixels equal</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>binary_op  Function handle pointing to the desired binary operation. The</dt><dd><p>function should take 2 objects with ‘.s’ and ‘.e’ attributes, e.g.
a sigvar object</p>
</dd>
</dl>
</section>
<section id="named-arguments">
<h3>Named arguments<a class="headerlink" href="#named-arguments" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>flip       Flip the order of the operands, e.g. perform “this - operand” if</dt><dd><p>flip is false, perform “operand - this” if flip is true.</p>
</dd>
<dt>npix       An array giving number of pixels in each bin. This argument should</dt><dd><p>have equal size to operand (assuming operand is numeric) and
sum(npix, [], ‘all’) must be equal to obj.num_pixels</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.do_unary_op">
<span class="sig-prename descclassname"><span class="pre">sqw.PixelData.&#64;PixelData.</span></span><span class="sig-name descname"><span class="pre">do_unary_op</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">unary_op</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.do_unary_op" title="Permalink to this definition"></a></dt>
<dd><p>Perform a unary operation on this object’s signal and variance arrays</p>
<section id="id102">
<h3>Input:<a class="headerlink" href="#id102" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>unary_op   Function handle pointing to the operation to perform. This</dt><dd><p>operation should take a sigvar object as an argument.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.equal_to_tol">
<span class="sig-prename descclassname"><span class="pre">sqw.PixelData.&#64;PixelData.</span></span><span class="sig-name descname"><span class="pre">equal_to_tol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">other_pix</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.equal_to_tol" title="Permalink to this definition"></a></dt>
<dd><p>EQUAL_TO_TOL Check if two PixelData objects are equal to a given tolerance</p>
<section id="id103">
<h3>Input:<a class="headerlink" href="#id103" title="Permalink to this heading"></a></h3>
<p>pix        The first pixel data object to compare.</p>
<p>other_pix  The second pixel data object to compare.</p>
<dl>
<dt>tol        Tolerance criterion for numeric arrays</dt><dd><p>(default = [0, 0] i.e. equality)
It has the form: [abs_tol, rel_tol] where</p>
<blockquote>
<div><p>abs_tol     absolute tolerance (&gt;=0; if =0 equality required)
rel_tol     relative tolerance (&gt;=0; if =0 equality required)</p>
</div></blockquote>
<p>If either criterion is satisfied then equality within tolerance
is accepted.</p>
<blockquote>
<div><dl class="simple">
<dt>Examples:</dt><dd><p>[1e-4, 1e-6]    absolute 1e-4 or relative 1e-6 required
[1e-4, 0]       absolute 1e-4 required
[0, 1e-6]       relative 1e-6 required
[0, 0]          equality required
0               equivalent to [0,0]</p>
</dd>
</dl>
</div></blockquote>
<p>A scalar tolerance can be given where the sign determines if
the tolerance is absolute or relative:</p>
<blockquote>
<div><p>+ve : absolute tolerance  abserr = abs(a-b)
-ve : relative tolerance  relerr = abs(a-b)/max(abs(a),abs(b))</p>
</div></blockquote>
<dl class="simple">
<dt>Examples:</dt><dd><p>1e-4            absolute tolerance, equivalent to [1e-4, 0]
-1e-6           relative tolerance, equivalent to [0, 1e-6]</p>
</dd>
</dl>
</dd>
</dl>
</section>
<section id="keyword-input">
<h3>Keyword Input:<a class="headerlink" href="#keyword-input" title="Permalink to this heading"></a></h3>
<p>nan_equal  Treat NaNs as equal (true or false; default=true).</p>
<dl class="simple">
<dt>name_a     Explicit name of variable a for use in messages</dt><dd><p>Usually not required, as the name of a variable will
be discovered. However, if the input argument is an array
element e.g. my_variable{3}  then the name is not
discoverable in Matlab, and default ‘input_1’ will be
used unless a different value is given with the keyword ‘name_a’.
(default = ‘input_1’).</p>
</dd>
<dt>name_b     Explicit name of variable b for use in messages.</dt><dd><p>The same comments apply as for ‘name_a’ except the default is
‘input_2’.
(default = ‘input_2’).</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.get_data">
<span class="sig-prename descclassname"><span class="pre">sqw.PixelData.&#64;PixelData.</span></span><span class="sig-name descname"><span class="pre">get_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">pix_fields</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.get_data" title="Permalink to this definition"></a></dt>
<dd><p>GET_DATA Retrieve data for a field, or fields, for the given pixel indices in
the full pixel block. If no pixel indices are given, the full range of pixels
is returned.</p>
<p>This method provides a convenient way of retrieving multiple fields
of data from the pixel block. When retrieving multiple fields, the
columns of data will be ordered corresponding to the order the fields
appear in the inputted cell array.</p>
<blockquote>
<div><dl class="simple">
<dt>&gt;&gt; sig_and_err = pix.get_data({‘signal’, ‘variance’})</dt><dd><p>retrieves the signal and variance over the whole range of pixels</p>
</dd>
<dt>&gt;&gt; run_det_id_range = pix.get_data({‘run_idx’, ‘detector_idx’}, 15640:19244);</dt><dd><p>retrieves the run and detector IDs for pixels 15640 to 19244</p>
</dd>
</dl>
</div></blockquote>
<section id="id104">
<h3>Input:<a class="headerlink" href="#id104" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>pix_fields       The name of a field, or a cell array of field names
abs_pix_indices  The pixel indices to retrieve, if not given, get full range.</p>
<blockquote>
<div><p>The syntax for these indices attempts to replicate indexing
into a regular Matlab array. You can use logical indices
as well as normal indices, and you can index into the array
“out-of-order”. However, you cannot use <cite>end</cite>, but it is
possible to achieve the same effect using the <cite>num_pixels</cite>
property.</p>
</div></blockquote>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.get_pix_in_ranges">
<span class="sig-prename descclassname"><span class="pre">sqw.PixelData.&#64;PixelData.</span></span><span class="sig-name descname"><span class="pre">get_pix_in_ranges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">abs_indices_starts</span></em>, <em class="sig-param"><span class="pre">block_sizes</span></em>, <em class="sig-param"><span class="pre">recalculate_pix_range</span></em>, <em class="sig-param"><span class="pre">keep_precision</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.get_pix_in_ranges" title="Permalink to this definition"></a></dt>
<dd><p>GET_PIX_IN_RANGES read pixels in the specified ranges
Ranges are inclusive.</p>
<blockquote>
<div><p>&gt;&gt; pix = get_pix_in_ranges([1, 12, 25], [6, 12, 27])</p>
</div></blockquote>
<section id="id105">
<h3>Input:<a class="headerlink" href="#id105" title="Permalink to this heading"></a></h3>
<p>pix_starts  Absolute indices of the starts of pixel ranges [Nx1 or 1xN array].
block_sizes The sizes of the blocks to read                [Nx1 or 1xN array].
Optional
recalculate_pix_range – if true, recalulate q-dE range of obrained</p>
<blockquote>
<div><p>pixels. Default – true</p>
</div></blockquote>
<dl class="simple">
<dt>keep_precision         –if true, load pixels in memory, as they are</dt><dd><p>stored on hdd (single precision pixels). If
false, convert pixels into double precision at
load. Default false</p>
</dd>
</dl>
</section>
<section id="id106">
<h3>Output:<a class="headerlink" href="#id106" title="Permalink to this heading"></a></h3>
<p>pix_out     A PixelData object containing the pixels in the given ranges.</p>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.get_pixels">
<span class="sig-prename descclassname"><span class="pre">sqw.PixelData.&#64;PixelData.</span></span><span class="sig-name descname"><span class="pre">get_pixels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">abs_pix_indices</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.get_pixels" title="Permalink to this definition"></a></dt>
<dd><p>Retrieve the pixels at the given indices in the full pixel block,
return a new PixelData object.</p>
<blockquote>
<div><p>&gt;&gt; pix_out = pix.get_pixels(15640:19244)  % retrieve pixels at indices 15640 to 19244</p>
<p>&gt;&gt; pix_out = pix.get_pixels([1, 0, 1])  % retrieve pixels at indices 1 and 3</p>
</div></blockquote>
<p>The function attempts to mimic the behaviour you would see when indexing into
a Matlab array. The difference being the returned object is a PixelData
object and not an array.</p>
<p>This function may be useful if you want to extract data for a particular
image bin.</p>
<section id="id107">
<h3>Input:<a class="headerlink" href="#id107" title="Permalink to this heading"></a></h3>
<blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>abs_pix_indices  A vector of positive integers or a vector of logicals.</dt><dd><p>The syntax for these indices attempts to replicate indexing
into a regular Matlab array. You can use logical indices
as well as normal indices, and you can index into the array
“out-of-order”. However, you cannot use <cite>end</cite>, but it is
possible to achieve the same effect using the <cite>num_pixels</cite>
property.</p>
</dd>
</dl>
</div></blockquote>
<p>Optional:
‘-ignore_range’  – if provided, new pix_object will not contain correct</p>
<blockquote>
<div><p>pixel ranges</p>
</div></blockquote>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.mask">
<span class="sig-prename descclassname"><span class="pre">sqw.PixelData.&#64;PixelData.</span></span><span class="sig-name descname"><span class="pre">mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">mask_array</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.mask" title="Permalink to this definition"></a></dt>
<dd><p>MASK remove the pixels specified by the input logical array</p>
<p>You must specify exactly one return argument when calling this function.</p>
<section id="id108">
<h3>Input:<a class="headerlink" href="#id108" title="Permalink to this heading"></a></h3>
<dl>
<dt>mask_array   A logical array specifying which pixels should be kept/removed</dt><dd><p>from the PixelData object. Must be of length equal to the number
of pixels in ‘obj’ or equal in size to the ‘npix’ argument. A
true/1 in the array indicates that the pixel at that index
should be retained, a false/0 indicates the pixel should be
removed.</p>
</dd>
<dt>npix         (Optional)</dt><dd><p>Array of integers that specify how many times each value in
mask_array should be replicated. This is useful for when masking
all pixels contributing to a bin. Size must be equal to that of
‘mask_array’. E.g.:</p>
<blockquote>
<div><p>mask_array = [      0,     1,     1,  0,     1]
npix       = [      3,     2,     2,  1,     2]
full_mask  = [0, 0, 0,  1, 1,  1, 1,  0,  1, 1]</p>
</div></blockquote>
<p>The npix array must account for all pixels in the PixelData
object i.e. sum(npix, ‘all’) == obj.num_pixels. It must also be
the same dimensions as ‘mask_array’ i.e.
all(size(mask_array) == size(npix)).</p>
</dd>
</dl>
</section>
<section id="id109">
<h3>Output:<a class="headerlink" href="#id109" title="Permalink to this heading"></a></h3>
<p>pix_out      A PixelData object containing only non-masked pixels.</p>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.move_to_page">
<span class="sig-prename descclassname"><span class="pre">sqw.PixelData.&#64;PixelData.</span></span><span class="sig-name descname"><span class="pre">move_to_page</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">page_number</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.move_to_page" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Set the object to point at the given page number</dt><dd><p>This function does nothing if the object is not file-backed or is
already on the given page</p>
</dd>
</dl>
<p>Inputs:
page_number – page number to move to</p>
<p>Returns:
page_number – the page this routine moved to
total_num_pages – total number of pages, present in the file</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.noisify">
<span class="sig-prename descclassname"><span class="pre">sqw.PixelData.&#64;PixelData.</span></span><span class="sig-name descname"><span class="pre">noisify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.noisify" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>the noisify functionality to be applied on a per-page basis to the
sqw object’s pixel data.
See noisify(sqw_object,…) for details of the input and the
Herbert noisify function for details of how the input is used.
This noisify adds random noise to the object’s signal array, and a fixed
error bar to the variance array, paging as required. The options in
varargin specify how that is done; see the above functions for details.
For options where the signal absolute maximum is used in the noise
scaling, a paged pre-scan of the signal provides the maximum over all
pages.</p>
<p>obj         The PixelData instance.
varargs     Options for random number distribution and noise magnitude</p>
<blockquote>
<div><p>scaling.</p>
</div></blockquote>
<dl class="simple">
<dt>pix_out     If specified, returns a “noisified” copy of the input data</dt><dd><p>Otherwise it is a reference to the input object, which is
“noisified” in place.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<hr class="docutils" />
<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.recalc_pix_range">
<span class="sig-prename descclassname"><span class="pre">sqw.PixelData.&#64;PixelData.</span></span><span class="sig-name descname"><span class="pre">recalc_pix_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.recalc_pix_range" title="Permalink to this definition"></a></dt>
<dd><p>Recalculate pixels range in the situations, where the
range for some reason appeared to be missing (i.e. loading pixels from
old style files) or changed through private interface (for efficiency)
and the internal integrity of the object has been violated.</p>
<p>returns obj for compatibility with recalc_pix_range method of
combine_pixel_info class, which may be used instead of PixelData
for the same purpose.
recalc_pix_range is a normal Matlab value object (not a handle object),
returning its changes in LHS</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.set_data">
<span class="sig-prename descclassname"><span class="pre">sqw.PixelData.&#64;PixelData.</span></span><span class="sig-name descname"><span class="pre">set_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">pix_fields</span></em>, <em class="sig-param"><span class="pre">data</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.set_data" title="Permalink to this definition"></a></dt>
<dd><p>SET_PIXELS Update the data on the given pixel data fields</p>
<p>The number of columns in ‘data’ must be equal to the number of fields in
‘pix_fields’. The number of rows in ‘data’ must be equal to the number of
elements in ‘abs_pix_indices’.</p>
<section id="examples">
<h3>Examples:<a class="headerlink" href="#examples" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>Set the first 100 pixels’ signal and variance to zero</dt><dd><p>&gt;&gt; set_data({‘signal’, ‘variance’}, zeros(2, 100), 1:100);</p>
</dd>
</dl>
</section>
<section id="id110">
<h3>Input:<a class="headerlink" href="#id110" title="Permalink to this heading"></a></h3>
<p>pix_fields       The name of a field, or a cell array of field names.
data             The data with which to set the given fields.
abs_pix_indices  The indices to set data on. If not specified all indices are</p>
<blockquote>
<div><p>updated and ‘size(data, 2)’ must equal to obj.num_pixels.</p>
</div></blockquote>
</section>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Contributing.html" class="btn btn-neutral float-left" title="Contributing to Horace" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="General_disclaimer.html" class="btn btn-neutral float-right" title="General disclaimer" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2006-2022, STFC RAL.
      <span class="lastupdated">Last updated on Nov 1, 2022, 7:30:31 AM.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
<br><br>
<a href="https://github.com/pace-neutrons/Horace/edit/master/documentation/user_docs/docs/API_Reference.rst">Click here to edit</a> or <a href="https://github.com/pace-neutrons/Horace/edit/master/documentation/user_docs/docs/new_page.rst">Click here to add new page</a> (requires <a href="https://github.com/login">GitHub account</a>).
<br>
For more info on editing <a href="Contributing.html">click here</a>.


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>