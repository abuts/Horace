<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>API Reference &mdash; Horace  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=b3ba4146"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="General disclaimer" href="General_disclaimer.html" />
    <link rel="prev" title="Contributing to Horace" href="Contributing.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Horace
              <img src="_static/150px-Quintus_Horatius_Flaccus.jpg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">Introduction and Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="User_guide.html">User’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="Horace_manual.html">Horace Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="Example_scripts.html">Example Scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="Citing.html">Citing Horace</a></li>
<li class="toctree-l1"><a class="reference internal" href="Developers.html">For Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="Contributing.html">Contributing to Horace</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-sqw.&#64;SQWDnDBase"><code class="docutils literal notranslate"><span class="pre">SQWDndBase</span></code> class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-sqw.&#64;Experiment"><code class="docutils literal notranslate"><span class="pre">Experiment</span></code> class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pixeldata-class"><code class="docutils literal notranslate"><span class="pre">PixelData</span></code> class</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="General_disclaimer.html">General disclaimer</a></li>
<li class="toctree-l1"><a class="reference internal" href="Previous_versions.html">Previous Versions</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Horace</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">API Reference</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/API_Reference.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="api-reference">
<h1><a class="toc-backref" href="#id47" role="doc-backlink">API Reference</a><a class="headerlink" href="#api-reference" title="Permalink to this heading"></a></h1>
<nav class="contents" id="table-of-contents">
<p class="topic-title">Table of Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#api-reference" id="id47">API Reference</a></p>
<ul>
<li><p><a class="reference internal" href="#module-sqw.&#64;SQWDnDBase" id="id48"><code class="docutils literal notranslate"><span class="pre">SQWDndBase</span></code> class</a></p></li>
<li><p><a class="reference internal" href="#module-sqw.&#64;Experiment" id="id49"><code class="docutils literal notranslate"><span class="pre">Experiment</span></code> class</a></p></li>
<li><p><a class="reference internal" href="#pixeldata-class" id="id50"><code class="docutils literal notranslate"><span class="pre">PixelData</span></code> class</a></p></li>
</ul>
</li>
</ul>
</nav>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">API Index</span></a></p></li>
</ul>
<section id="module-sqw.&#64;SQWDnDBase">
<span id="sqwdndbase-class"></span><h2><a class="toc-backref" href="#id48" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">SQWDndBase</span></code> class</a><a class="headerlink" href="#module-sqw.@SQWDnDBase" title="Permalink to this heading"></a></h2>
<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.multifit_sqw">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">multifit_sqw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.multifit_sqw" title="Permalink to this definition"></a></dt>
<dd><p>Simultaneously fit function(s) of S(Q,w)to one or more sqw objects</p>
<blockquote>
<div><blockquote>
<div><p>&gt;&gt; myobj = multifit_sqw (w1, w2, …)      % w1, w2 objects or arrays of objects</p>
</div></blockquote>
<p>This creates a fitting object of class mfclass_Horace_sqw with the provided data,
which can then be manipulated to add further data, set the fitting
functions, initial parameter values etc. and fit or simulate the data.
For details about how to do this  &lt;a href=”matlab:help(‘mfclass_Horace_sqw’);”&gt;Click here&lt;/a&gt;</p>
<p>For example:</p>
<blockquote>
<div><dl class="simple">
<dt>&gt;&gt; myobj = multifit_sqw (w1, w2, …); % set the data</dt><dd><p>:</p>
</dd>
</dl>
<p>&gt;&gt; myobj = myobj.set_fun (&#64;function_name, pars);  % set forgraound function(s)
&gt;&gt; myobj = myobj.set_bfun (&#64;function_name, pars); % set background function(s)</p>
<blockquote>
<div><p>:</p>
</div></blockquote>
<p>&gt;&gt; myobj = myobj.set_free (pfree);      % set which parameters are floating
&gt;&gt; myobj = myobj.set_bfree (bpfree);    % set which parameters are floating
&gt;&gt; [wfit,fitpars] = myobj.fit;          % perform fit</p>
</div></blockquote>
<p>This method fits model(s) for S(Q,w) as the foreground function(s), and
function(s) of the plot axes for the background function(s)</p>
<p>For the format of foreground fit functions:
&lt;a href=”matlab:edit(‘example_sqw_spin_waves’);”&gt;Damped spin waves&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_sqw_flat_mode’);”&gt;Dispersionless excitations&lt;/a&gt;</p>
<p>The format of the background fit functions depends on the number of plot
axes for each sqw object. For examples see:
&lt;a href=”matlab:edit(‘example_1d_function’);”&gt;example_1d_function&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_2d_function’);”&gt;example_2d_function&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_3d_function’);”&gt;example_3d_function&lt;/a&gt;</p>
<p>See also multifit multifit_sqw_sqw</p>
</div></blockquote>
<blockquote>
<div><p>method_name = ‘multifit_sqw’
mfclass_name = ‘mfclass_Horace_sqw’
function_tag = ‘of S(Q,w) ‘</p>
<p>multifit_doc = fullfile(fileparts(which(‘multifit’)),’_docify’)
sqw_doc = fullfile(fileparts(which(‘mfclass_Horace’)),’_docify’)</p>
<p>doc_multifit_header = fullfile(multifit_doc,’doc_multifit_header.m’)
doc_fit_functions = fullfile(sqw_doc,’doc_multifit_sqw_fit_functions_for_sqw.m’)</p>
</div></blockquote>
<blockquote>
<div><blockquote>
<div><p>&lt;#file:&gt;  &lt;doc_fit_functions&gt;</p>
</div></blockquote>
<p>See also multifit multifit_sqw_sqw</p>
<p>&lt;#doc_end:&gt;</p>
</div></blockquote>
</dd></dl>

<hr class="docutils" />
<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.multifit_func">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">multifit_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.multifit_func" title="Permalink to this definition"></a></dt>
<dd><p>Simultaneously fit function(s) to one or more sqw objects</p>
<blockquote>
<div><p>&gt;&gt; myobj = multifit_func (w1, w2, …)      % w1, w2 objects or arrays of objects</p>
</div></blockquote>
<p>This creates a fitting object of class mfclass_Horace with the provided data,
which can then be manipulated to add further data, set the fitting
functions, initial parameter values etc. and fit or simulate the data.
For details about how to do this  &lt;a href=”matlab:help(‘mfclass_Horace’);”&gt;Click here&lt;/a&gt;</p>
<p>For example:</p>
<blockquote>
<div><dl class="simple">
<dt>&gt;&gt; myobj = multifit_func (w1, w2, …); % set the data</dt><dd><p>:</p>
</dd>
</dl>
<p>&gt;&gt; myobj = myobj.set_fun (&#64;function_name, pars);  % set forgraound function(s)
&gt;&gt; myobj = myobj.set_bfun (&#64;function_name, pars); % set background function(s)</p>
<blockquote>
<div><p>:</p>
</div></blockquote>
<p>&gt;&gt; myobj = myobj.set_free (pfree);      % set which parameters are floating
&gt;&gt; myobj = myobj.set_bfree (bpfree);    % set which parameters are floating
&gt;&gt; [wfit,fitpars] = myobj.fit;          % perform fit</p>
</div></blockquote>
<p>This method fits function(s) of the plot axes for both the foreground and
the background function(s). The format of the fit functions depends on
the number of plot axes for each sqw object. For examples see:
&lt;a href=”matlab:edit(‘example_1d_function’);”&gt;example_1d_function&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_2d_function’);”&gt;example_2d_function&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_3d_function’);”&gt;example_3d_function&lt;/a&gt;</p>
<p>See also multifit_sqw multifit_sqw_sqw</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.unary_op_manager">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">unary_op_manager</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em>, <em class="sig-param"><span class="pre">unary_op</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.unary_op_manager" title="Permalink to this definition"></a></dt>
<dd><p>Implements a unary operation for objects with a signal and a variance array.</p>
<blockquote>
<div><p>&gt;&gt; w = unary_op_manager(w1, unary_op)</p>
</div></blockquote>
<p>Most unary operations on MATLAB double arrays are permitted (e.g. acos,
sqrt, log10…) and are applied element by element to the signal and
variance arrays.</p>
<section id="input">
<h3>Input:<a class="headerlink" href="#input" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
<p>unary_op    Function handle to the unary operator.</p>
</div></blockquote>
</section>
<section id="output">
<h3>Output:<a class="headerlink" href="#output" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
<p>NOTES:
This is a generic template method - works for any class (including sigvar)
but the indicated blocks may need to be edited for a particular class.</p>
<p>Requires that objects have the following methods to find the size of the
public signal and variance arrays, create a sigvar object from those
arrays, and set them from another sigvar object.</p>
<blockquote>
<div><dl class="simple">
<dt>&gt;&gt; sz = sigvar_size(obj)    % Returns size of public signal and variance</dt><dd><p>% arrays</p>
</dd>
<dt>&gt;&gt; w = sigvar(obj)          % Create a sigvar object from the public</dt><dd><p>% signal and variance arrays</p>
</dd>
<dt>&gt;&gt; obj = sigvar_set(obj,w)  % Set signal and variance in an object from</dt><dd><p>% those in a sigvar object</p>
</dd>
</dl>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.calculate_qsqr_bins">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">calculate_qsqr_bins</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.calculate_qsqr_bins" title="Permalink to this definition"></a></dt>
<dd><p>Calculate <a href="#id1"><span class="problematic" id="id2">|</span></a>Q|^2 for the centres of the bins of an n-dimensional sqw dataset</p>
<blockquote>
<div><p>&gt;&gt; qsqr = calculate_qsqr_bins (win)</p>
</div></blockquote>
<section id="id3">
<h3>Input:<a class="headerlink" href="#id3" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>win     Input sqw object</p>
</div></blockquote>
</section>
<section id="id4">
<h3>Output:<a class="headerlink" href="#id4" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>qsqr    <a href="#id5"><span class="problematic" id="id6">|</span></a>Q|^2 for each bin in the dataset for a single energy bin (column vector)</p>
<dl class="simple">
<dt>en      Column vector of energy bin centres. If energy was an integration axis,</dt><dd><p>then returns the centre of the energy integration range</p>
</dd>
</dl>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.multifit_sqw_sqw">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">multifit_sqw_sqw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.multifit_sqw_sqw" title="Permalink to this definition"></a></dt>
<dd><p>Simultaneously fit function(s) of S(Q,w)to one or more sqw objects</p>
<blockquote>
<div><blockquote>
<div><p>&gt;&gt; myobj = multifit_sqw_sqw (w1, w2, …)      % w1, w2 objects or arrays of objects</p>
</div></blockquote>
<p>This creates a fitting object of class mfclass_Horace_sqw_sqw with the provided data,
which can then be manipulated to add further data, set the fitting
functions, initial parameter values etc. and fit or simulate the data.
For details about how to do this  &lt;a href=”matlab:help(‘mfclass_Horace_sqw_sqw’);”&gt;Click here&lt;/a&gt;</p>
<p>For example:</p>
<blockquote>
<div><dl class="simple">
<dt>&gt;&gt; myobj = multifit_sqw_sqw (w1, w2, …); % set the data</dt><dd><p>:</p>
</dd>
</dl>
<p>&gt;&gt; myobj = myobj.set_fun (&#64;function_name, pars);  % set forgraound function(s)
&gt;&gt; myobj = myobj.set_bfun (&#64;function_name, pars); % set background function(s)</p>
<blockquote>
<div><p>:</p>
</div></blockquote>
<p>&gt;&gt; myobj = myobj.set_free (pfree);      % set which parameters are floating
&gt;&gt; myobj = myobj.set_bfree (bpfree);    % set which parameters are floating
&gt;&gt; [wfit,fitpars] = myobj.fit;          % perform fit</p>
</div></blockquote>
<p>This method fits function(s) of S(Q,w) as both the foreground and
the background function(s). For the format of the fit functions:
&lt;a href=”matlab:edit(‘example_sqw_spin_waves’);”&gt;Damped spin waves&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_sqw_flat_mode’);”&gt;Dispersionless excitations&lt;/a&gt;</p>
<p>See also multifit multifit_sqw</p>
</div></blockquote>
<blockquote>
<div><p>method_name = ‘multifit_sqw_sqw’
mfclass_name = ‘mfclass_Horace_sqw_sqw’
function_tag = ‘of S(Q,w) ‘</p>
<p>multifit_doc = fullfile(fileparts(which(‘multifit’)),’_docify’)
sqw_doc = fullfile(fileparts(which(‘mfclass_Horace’)),’_docify’)</p>
<p>doc_multifit_header = fullfile(multifit_doc,’doc_multifit_header.m’)
doc_fit_functions = fullfile(sqw_doc,’doc_multifit_sqw_sqw_fit_functions_for_sqw.m’)</p>
</div></blockquote>
<blockquote>
<div><blockquote>
<div><p>&lt;#file:&gt;  &lt;doc_fit_functions&gt;</p>
</div></blockquote>
<p>See also multifit multifit_sqw</p>
<p>&lt;#doc_end:&gt;</p>
</div></blockquote>
</dd></dl>

<hr class="docutils" />
<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.save">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.save" title="Permalink to this definition"></a></dt>
<dd><p>Save a sqw object or array of sqw objects to a binary sqw file with
recommended version</p>
<blockquote>
<div><p>&gt;&gt; save (w)              % prompt for file
&gt;&gt; save (w, file)        % save to file with the name provided
&gt;&gt; save (w, file,loader) % save file using specific binary data</p>
<blockquote>
<div><blockquote>
<div><p>accessor</p>
</div></blockquote>
<p>(“-update” option, if provided with together
with loader will be ignored)</p>
</div></blockquote>
<dl class="simple">
<dt>&gt;&gt; save (w, file,[‘-parallel’<a href="#id7"><span class="problematic" id="id8">|</span></a>JobDispatcher])</dt><dd><p>combine file using parallel algorithm.
Useful and would works only if (when) pix
value of sqw object data is set up to the
instance of pix_combine_info class,
containing information on the partial
tmp files, written by filebased gen_sqw or
cut algorithm</p>
</dd>
<dt>&gt;&gt; save (w, file,’-update’) % if the target file exist, update it to</dt><dd><p>latest format if this is possible. If
update is possible, pixels in file will not be
overwritten.</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>Input:</dt><dd><p>w       sqw object
file    [optional] File for output. if none given, then prompted for a file</p>
<p>Note that if w is an array of sqw objects then file must be a cell
array of filenames of the same size.</p>
</dd>
</dl>
<p>Optional output:
cl – running instance of parallel cluster, used to combine multiple tmp</p>
<blockquote>
<div><blockquote>
<div><p>files together if pix field of sqw object contains pix_combine_into
and -parallel option or parallel cluster itself are provided as
inpout. Empty in any other case</p>
</div></blockquote>
<p>TODO: currently empty. May re-enable when parallel saving is
implemented properly</p>
</div></blockquote>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.calculate_qsqr_w_bins">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">calculate_qsqr_w_bins</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.calculate_qsqr_w_bins" title="Permalink to this definition"></a></dt>
<dd><p>Calculate <a href="#id9"><span class="problematic" id="id10">|</span></a>Q|^2 for the centres of the bins of an n-dimensional sqw dataset</p>
<blockquote>
<div><p>&gt;&gt; qsqr_w = calculate_qsqr_w_bins (win)
&gt;&gt; qsqr_w = calculate_qsqr_w_bins (win,’-boundaries’)
&gt;&gt; qsqr_w = calculate_qsqr_w_bins (win,’-edges’)</p>
</div></blockquote>
<section id="id11">
<h3>Input:<a class="headerlink" href="#id11" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>win         Input sqw object</p>
</div></blockquote>
<p>Optional arguments:
‘-boundaries’  Return qh,qk,ql,en at vertices of bins, not centres
‘-edges’       Return qh,qk,ql,en at vertices of the hyper cuboid that</p>
<blockquote>
<div><p>encloses the plot axes</p>
</div></blockquote>
</section>
<section id="id12">
<h3>Output:<a class="headerlink" href="#id12" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl>
<dt>qsqr_w      <a href="#id13"><span class="problematic" id="id14">|</span></a>Q|^2 and energy for each bin in the dataset. Arrays are packaged</dt><dd><p>as cell arrays of column vectors: qsqr_w{1} is <a href="#id15"><span class="problematic" id="id16">|</span></a>Q|^2 and qsqr_w{2}
is energy</p>
<blockquote>
<div><p>Note that the centre of the integration range is used in</p>
</div></blockquote>
<p>the calculation of qh,qk,ql,en even with the options
‘boundaries’ or ‘edges’</p>
<blockquote>
<div><p>If one or both of the integration ranges is infinite, then</p>
</div></blockquote>
<p>the value of the corresponding coordinate is taken as zero.</p>
</dd>
</dl>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.SQWDnDBase">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">SQWDnDBase</span></span><a class="headerlink" href="#sqw.@SQWDnDBase.SQWDnDBase" title="Permalink to this definition"></a></dt>
<dd><p>SQWDnDBase Abstract SQW/DnD object base class</p>
<p>Abstract class defining common API and attributes of the SQW and
DnD objects</p>
<div class="members docutils container">
<dl>
<dt>Method Summary</dt><dd><dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.SQWDnDBase.calculate_qsqr_bins">
<span class="sig-name descname"><span class="pre">calculate_qsqr_bins</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.SQWDnDBase.calculate_qsqr_bins" title="Permalink to this definition"></a></dt>
<dd><p>Calculate <a href="#id17"><span class="problematic" id="id18">|</span></a>Q|^2 for the centres of the bins of an n-dimensional sqw dataset</p>
<blockquote>
<div><p>&gt;&gt; qsqr = calculate_qsqr_bins (win)</p>
</div></blockquote>
<section id="id19">
<h3>Input:<a class="headerlink" href="#id19" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>win     Input sqw object</p>
</div></blockquote>
</section>
<section id="id20">
<h3>Output:<a class="headerlink" href="#id20" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>qsqr    <a href="#id21"><span class="problematic" id="id22">|</span></a>Q|^2 for each bin in the dataset for a single energy bin (column vector)</p>
<dl class="simple">
<dt>en      Column vector of energy bin centres. If energy was an integration axis,</dt><dd><p>then returns the centre of the energy integration range</p>
</dd>
</dl>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.SQWDnDBase.calculate_qsqr_w_bins">
<span class="sig-name descname"><span class="pre">calculate_qsqr_w_bins</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.SQWDnDBase.calculate_qsqr_w_bins" title="Permalink to this definition"></a></dt>
<dd><p>Calculate <a href="#id23"><span class="problematic" id="id24">|</span></a>Q|^2 for the centres of the bins of an n-dimensional sqw dataset</p>
<blockquote>
<div><p>&gt;&gt; qsqr_w = calculate_qsqr_w_bins (win)
&gt;&gt; qsqr_w = calculate_qsqr_w_bins (win,’-boundaries’)
&gt;&gt; qsqr_w = calculate_qsqr_w_bins (win,’-edges’)</p>
</div></blockquote>
<section id="id25">
<h3>Input:<a class="headerlink" href="#id25" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>win         Input sqw object</p>
</div></blockquote>
<p>Optional arguments:
‘-boundaries’  Return qh,qk,ql,en at vertices of bins, not centres
‘-edges’       Return qh,qk,ql,en at vertices of the hyper cuboid that</p>
<blockquote>
<div><p>encloses the plot axes</p>
</div></blockquote>
</section>
<section id="id26">
<h3>Output:<a class="headerlink" href="#id26" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl>
<dt>qsqr_w      <a href="#id27"><span class="problematic" id="id28">|</span></a>Q|^2 and energy for each bin in the dataset. Arrays are packaged</dt><dd><p>as cell arrays of column vectors: qsqr_w{1} is <a href="#id29"><span class="problematic" id="id30">|</span></a>Q|^2 and qsqr_w{2}
is energy</p>
<blockquote>
<div><p>Note that the centre of the integration range is used in</p>
</div></blockquote>
<p>the calculation of qh,qk,ql,en even with the options
‘boundaries’ or ‘edges’</p>
<blockquote>
<div><p>If one or both of the integration ranges is infinite, then</p>
</div></blockquote>
<p>the value of the corresponding coordinate is taken as zero.</p>
</dd>
</dl>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.SQWDnDBase.disp2sqw_eval">
<span class="sig-name descname"><span class="pre">disp2sqw_eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">dispreln</span></em>, <em class="sig-param"><span class="pre">pars</span></em>, <em class="sig-param"><span class="pre">fwhh</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.SQWDnDBase.disp2sqw_eval" title="Permalink to this definition"></a></dt>
<dd><p>Calculate sqw for a model scattering function</p>
<blockquote>
<div><p>&gt;&gt; wout = disp2sqw_eval(win,dispreln,pars,fwhh,varargin)</p>
</div></blockquote>
<section id="id31">
<h3>Input:<a class="headerlink" href="#id31" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl>
<dt>win         Dataset, or array of datasets, that provides the axes and points</dt><dd><p>for the calculation</p>
</dd>
<dt>dispreln    Handle to function that calculates the dispersion relation w(Q) and</dt><dd><p>spectral weight, s(Q)
Must have form:</p>
<blockquote>
<div><blockquote>
<div><p>[w,s] = dispreln (qh,qk,ql,p)</p>
</div></blockquote>
<dl class="simple">
<dt>where</dt><dd><dl class="simple">
<dt>qh,qk,ql    Arrays containing the coordinates of a set of points</dt><dd><p>in reciprocal lattice units</p>
</dd>
<dt>p           Vector of parameters needed by dispersion function</dt><dd><p>e.g. [A,js,gam] as intensity, exchange, lifetime</p>
</dd>
<dt>w           Array of corresponding energies, or, if more than</dt><dd><p>one dispersion relation, a cell array of arrays.</p>
</dd>
<dt>s           Array of spectral weights, or, if more than</dt><dd><p>one dispersion relation, a cell array of arrays.</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>More general form is:</dt><dd><blockquote>
<div><p>[w,s] = dispreln (qh,qk,ql,p,c1,c2,..)</p>
</div></blockquote>
<dl class="simple">
<dt>where</dt><dd><dl class="simple">
<dt>p           Typically a vector of parameters that we might want</dt><dd><p>to fit in a least-squares algorithm</p>
</dd>
<dt>c1,c2,…   Other constant parameters e.g. file name for look-up</dt><dd><p>table.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>pars        Arguments needed by the function. Most commonly, a vector of parameter</dt><dd><p>values e.g. [A,js,gam] as intensity, exchange, lifetime. If a more general
set of parameters is required by the function, then
package these into a cell array and pass that as pars. In the example
above then pars = {p, c1, c2, …}</p>
</dd>
<dt>fwhh       Parametrizes the resolution function. There are three</dt><dd><blockquote>
<div><p>possible input values of fwhh:</p>
</div></blockquote>
<dl>
<dt>double              A single FWHM value determines the FWHM of the</dt><dd><p>Gaussian resolution function</p>
</dd>
<dt>function_handle     A function that produces the FWHM value as a</dt><dd><p>function of energy transfer, it has to have the
following simple header (where omega can be a row
vector of energies:</p>
<blockquote>
<div><p>dE = resfun(omega)</p>
</div></blockquote>
</dd>
<dt>function_handle     A function handle of a function with two input</dt><dd><dl class="simple">
<dt>parameters with the following header:</dt><dd><p>I = shapefun(Emat,omega)</p>
</dd>
</dl>
<p>where Emat is a matrix with dimensions of [nQ nE]
and omega is a column vector with nQ elements. The
shapefun produces a peakshape for every Q point
centered at the given omega and normalized to one.
The output I has the same dimensions as the
input Emat.</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>Optional arguments: (varargin)</p>
<blockquote>
<div><dl>
<dt>‘-al[l]’  Requests that the calculated sqw be returned over</dt><dd><p>the whole of the domain of the input dataset. If not given, then
the function will be returned only at those points of the dataset
that contain data.
Applies only to input with no pixel information - it is ignored if
full sqw object.</p>
</dd>
<dt>‘-av[erage]’ Requests that the calculated sqw be computed for the</dt><dd><p>average values of h,k,l of the pixels in a bin, not for each
pixel individually. Reduces cost of expensive calculations.</p>
<blockquote>
<div><p>Applies only to the case of sqw object with pixel information - it is</p>
</div></blockquote>
<p>ignored if dnd type object.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id32">
<h3>Output:<a class="headerlink" href="#id32" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>wout        Output dataset or array of datasets</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.SQWDnDBase.equal_to_tol">
<span class="sig-name descname"><span class="pre">equal_to_tol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em>, <em class="sig-param"><span class="pre">w2</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.SQWDnDBase.equal_to_tol" title="Permalink to this definition"></a></dt>
<dd><p>Check if two sqw objects are equal to a given tolerance</p>
<blockquote>
<div><p>&gt;&gt; ok = equal_to_tol (a, b)
&gt;&gt; ok = equal_to_tol (a, b, tol)
&gt;&gt; ok = equal_to_tol (…, keyword1, val1, keyword2, val2,…)
&gt;&gt; [ok, mess] = equal_to_tol (…)</p>
</div></blockquote>
<dl class="simple">
<dt>Class specific version of the generic equal_to_tol that by default</dt><dd><ol class="arabic simple">
<li><p>assumes NaN are equivalent (see option ‘nan_equal’), and</p></li>
<li><p>ignores the order of pixels within a bin as the order is irrelevant
(change the default with option ‘reorder’)</p></li>
</ol>
</dd>
</dl>
<p>In addition, it is possible to check the contents of just a random
fraction of non-empty bins (see option ‘fraction’) in order to speed up
the comparison of large objects.</p>
<section id="id33">
<h3>Input:<a class="headerlink" href="#id33" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w1,w2   Test objects (scalar objects, or arrays of objects with same sizes)</p>
<dl>
<dt>tol     Tolerance criterion for numeric arrays (Default: [0,0] i.e. equality)</dt><dd><dl class="simple">
<dt>It has the form: [abstol, reltol] where</dt><dd><p>abstol     absolute tolerance (&gt;=0; if =0 equality required)
reltol     relative tolerance (&gt;=0; if =0 equality required)</p>
</dd>
</dl>
<p>If either criterion is satified then equality within tolerance
is accepted.</p>
<blockquote>
<div><dl class="simple">
<dt>Examples:</dt><dd><p>[1e-4, 1e-6]    absolute 1e-4 or relative 1e-6 required
[1e-4, 0]       absolute 1e-4 required
[0, 1e-6]       relative 1e-6 required
[0, 0]          equality required
0               equivalent to [0,0]</p>
</dd>
</dl>
</div></blockquote>
<p>For backwards compatibility, a scalar tolerance can be given
where the sign determines absolute or relative tolerance</p>
<blockquote>
<div><blockquote>
<div><p>+ve : absolute tolerance  abserr = abs(a-b)
-ve : relative tolerance  relerr = abs(a-b)/max(abs(a),abs(b))</p>
</div></blockquote>
<dl class="simple">
<dt>Examples:</dt><dd><p>1e-4            absolute tolerance, equivalent to [1e-4, 0]
-1e-6           relative tolerance, equivalent to [0, 1e-6]</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>[To apply an absolute as well as a relative tolerance with a</dt><dd><p>scalar negative value, set the value of the legacy keyword</p>
</dd>
</dl>
<p>‘min_denominator’ (see below)]</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>Valid keywords are:</dt><dd><p>‘nan_equal’      Treat NaNs as equal (true or false; default=true)</p>
<dl>
<dt>‘ignore_str’     Ignore the length and content of strings or cell arrays</dt><dd><p>of strings (true or false; default=false)</p>
</dd>
<dt>‘reorder’        Ignore the order of pixels within each bin</dt><dd><dl class="simple">
<dt>(true or false; default=true)</dt><dd><p>Only applies if sqw-type object</p>
</dd>
</dl>
</dd>
<dt>‘fraction’       Compare pixels in only a fraction of the non-empty bins</dt><dd><dl class="simple">
<dt>(0&lt;= fracton &lt;= 1; default=1 i.e. test all bins)</dt><dd><p>Only applies if sqw-type object</p>
</dd>
</dl>
</dd>
<dt>‘-ignore_date’   (provided without additional values, so its presence in</dt><dd><blockquote>
<div><blockquote>
<div><p>the sequence of keywords means true). If provided,
ignore file creation date stored in main header.</p>
</div></blockquote>
<p>The reorder and fraction options are available because the order of the</p>
</div></blockquote>
<p>pixels within the pix array for a given bin is unimportant. Reordering
takes time, however, so the option to test on a few bins is given.</p>
</dd>
</dl>
</dd>
</dl>
</section>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.SQWDnDBase.mask_points">
<span class="sig-name descname"><span class="pre">mask_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.SQWDnDBase.mask_points" title="Permalink to this definition"></a></dt>
<dd><p>TODO: Does not look like this function should be here</p>
<p>Determine the points to keep on the basis of ranges and mask array.</p>
<blockquote>
<div><p>&gt;&gt; sel = mask_points (win, ‘keep’, xkeep, ‘remove’, xremove, ‘mask’, mask)</p>
</div></blockquote>
<p>or any selection (in any order) of the keyword-argument pairs e.g.</p>
<blockquote>
<div><p>&gt;&gt; sel = mask_points (win, ‘mask’, mask, ‘remove’, xremove)</p>
</div></blockquote>
<section id="id34">
<h3>Input:<a class="headerlink" href="#id34" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>win     Input sqw object</p>
<dl>
<dt>xkeep   Ranges of display axes to retain for fitting. A range is specified by an array</dt><dd><p>of numbers which define a hypercube.
For example in case of two dimensions:</p>
<blockquote>
<div><p>[xlo, xhi, ylo, yhi]</p>
</div></blockquote>
<dl>
<dt>or in the case of n-dimensions:</dt><dd><blockquote>
<div><p>[x1_lo, x1_hi, x2_lo, x2_hi,…, xn_lo, xn_hi]</p>
</div></blockquote>
<dl class="simple">
<dt>e.g. 1D: [50,70]</dt><dd><p>2D: [1,2,130,160]</p>
</dd>
</dl>
</dd>
<dt>More than one range can be defined in rows,</dt><dd><blockquote>
<div><p>[Range_1; Range_2; Range_3;…; Range_m]</p>
</div></blockquote>
<p>where each of the ranges are given in the format above.</p>
</dd>
</dl>
</dd>
</dl>
<p>xremove Ranges of display axes to remove from fitting.</p>
<dl>
<dt>mask    Mask array of same number of elements as data array: 1 to keep, 0 to remove</dt><dd><blockquote>
<div><p>Note: mask will be applied to the stored data array</p>
</div></blockquote>
<p>according as the projection axes, not the display axes.
Thus permuting the display axes does not alter the
effect of masking the data. The mask array works
consistently with the input required by the mask method.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id35">
<h3>Output:<a class="headerlink" href="#id35" title="Permalink to this heading"></a></h3>
<blockquote>
<div><blockquote>
<div><p>sel     Mask array of same shape as <a href="#id51"><span class="problematic" id="id52">data_</span></a>. true for bins to keep, false to discard.</p>
</div></blockquote>
<p>Advanced use: in addition the following two arguments, if present, suppress failure or the
display of informational messges. Instead, the messages are returned to be used as desired.</p>
<blockquote>
<div><p>ok      =true if worked, =false if error</p>
<p>mess    messages: if ok=true then informational or warning, if ok=false then the error message</p>
</div></blockquote>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.SQWDnDBase.multifit_func">
<span class="sig-name descname"><span class="pre">multifit_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.SQWDnDBase.multifit_func" title="Permalink to this definition"></a></dt>
<dd><p>Simultaneously fit function(s) to one or more sqw objects</p>
<blockquote>
<div><p>&gt;&gt; myobj = multifit_func (w1, w2, …)      % w1, w2 objects or arrays of objects</p>
</div></blockquote>
<p>This creates a fitting object of class mfclass_Horace with the provided data,
which can then be manipulated to add further data, set the fitting
functions, initial parameter values etc. and fit or simulate the data.
For details about how to do this  &lt;a href=”matlab:help(‘mfclass_Horace’);”&gt;Click here&lt;/a&gt;</p>
<p>For example:</p>
<blockquote>
<div><dl class="simple">
<dt>&gt;&gt; myobj = multifit_func (w1, w2, …); % set the data</dt><dd><p>:</p>
</dd>
</dl>
<p>&gt;&gt; myobj = myobj.set_fun (&#64;function_name, pars);  % set forgraound function(s)
&gt;&gt; myobj = myobj.set_bfun (&#64;function_name, pars); % set background function(s)</p>
<blockquote>
<div><p>:</p>
</div></blockquote>
<p>&gt;&gt; myobj = myobj.set_free (pfree);      % set which parameters are floating
&gt;&gt; myobj = myobj.set_bfree (bpfree);    % set which parameters are floating
&gt;&gt; [wfit,fitpars] = myobj.fit;          % perform fit</p>
</div></blockquote>
<p>This method fits function(s) of the plot axes for both the foreground and
the background function(s). The format of the fit functions depends on
the number of plot axes for each sqw object. For examples see:
&lt;a href=”matlab:edit(‘example_1d_function’);”&gt;example_1d_function&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_2d_function’);”&gt;example_2d_function&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_3d_function’);”&gt;example_3d_function&lt;/a&gt;</p>
<p>See also multifit_sqw multifit_sqw_sqw</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.SQWDnDBase.multifit_sqw">
<span class="sig-name descname"><span class="pre">multifit_sqw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.SQWDnDBase.multifit_sqw" title="Permalink to this definition"></a></dt>
<dd><p>Simultaneously fit function(s) of S(Q,w)to one or more sqw objects</p>
<blockquote>
<div><blockquote>
<div><p>&gt;&gt; myobj = multifit_sqw (w1, w2, …)      % w1, w2 objects or arrays of objects</p>
</div></blockquote>
<p>This creates a fitting object of class mfclass_Horace_sqw with the provided data,
which can then be manipulated to add further data, set the fitting
functions, initial parameter values etc. and fit or simulate the data.
For details about how to do this  &lt;a href=”matlab:help(‘mfclass_Horace_sqw’);”&gt;Click here&lt;/a&gt;</p>
<p>For example:</p>
<blockquote>
<div><dl class="simple">
<dt>&gt;&gt; myobj = multifit_sqw (w1, w2, …); % set the data</dt><dd><p>:</p>
</dd>
</dl>
<p>&gt;&gt; myobj = myobj.set_fun (&#64;function_name, pars);  % set forgraound function(s)
&gt;&gt; myobj = myobj.set_bfun (&#64;function_name, pars); % set background function(s)</p>
<blockquote>
<div><p>:</p>
</div></blockquote>
<p>&gt;&gt; myobj = myobj.set_free (pfree);      % set which parameters are floating
&gt;&gt; myobj = myobj.set_bfree (bpfree);    % set which parameters are floating
&gt;&gt; [wfit,fitpars] = myobj.fit;          % perform fit</p>
</div></blockquote>
<p>This method fits model(s) for S(Q,w) as the foreground function(s), and
function(s) of the plot axes for the background function(s)</p>
<p>For the format of foreground fit functions:
&lt;a href=”matlab:edit(‘example_sqw_spin_waves’);”&gt;Damped spin waves&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_sqw_flat_mode’);”&gt;Dispersionless excitations&lt;/a&gt;</p>
<p>The format of the background fit functions depends on the number of plot
axes for each sqw object. For examples see:
&lt;a href=”matlab:edit(‘example_1d_function’);”&gt;example_1d_function&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_2d_function’);”&gt;example_2d_function&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_3d_function’);”&gt;example_3d_function&lt;/a&gt;</p>
<p>See also multifit multifit_sqw_sqw</p>
</div></blockquote>
<blockquote>
<div><p>method_name = ‘multifit_sqw’
mfclass_name = ‘mfclass_Horace_sqw’
function_tag = ‘of S(Q,w) ‘</p>
<p>multifit_doc = fullfile(fileparts(which(‘multifit’)),’_docify’)
sqw_doc = fullfile(fileparts(which(‘mfclass_Horace’)),’_docify’)</p>
<p>doc_multifit_header = fullfile(multifit_doc,’doc_multifit_header.m’)
doc_fit_functions = fullfile(sqw_doc,’doc_multifit_sqw_fit_functions_for_sqw.m’)</p>
</div></blockquote>
<blockquote>
<div><blockquote>
<div><p>&lt;#file:&gt;  &lt;doc_fit_functions&gt;</p>
</div></blockquote>
<p>See also multifit multifit_sqw_sqw</p>
<p>&lt;#doc_end:&gt;</p>
</div></blockquote>
</dd></dl>

<hr class="docutils" />
<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.SQWDnDBase.multifit_sqw_sqw">
<span class="sig-name descname"><span class="pre">multifit_sqw_sqw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.SQWDnDBase.multifit_sqw_sqw" title="Permalink to this definition"></a></dt>
<dd><p>Simultaneously fit function(s) of S(Q,w)to one or more sqw objects</p>
<blockquote>
<div><blockquote>
<div><p>&gt;&gt; myobj = multifit_sqw_sqw (w1, w2, …)      % w1, w2 objects or arrays of objects</p>
</div></blockquote>
<p>This creates a fitting object of class mfclass_Horace_sqw_sqw with the provided data,
which can then be manipulated to add further data, set the fitting
functions, initial parameter values etc. and fit or simulate the data.
For details about how to do this  &lt;a href=”matlab:help(‘mfclass_Horace_sqw_sqw’);”&gt;Click here&lt;/a&gt;</p>
<p>For example:</p>
<blockquote>
<div><dl class="simple">
<dt>&gt;&gt; myobj = multifit_sqw_sqw (w1, w2, …); % set the data</dt><dd><p>:</p>
</dd>
</dl>
<p>&gt;&gt; myobj = myobj.set_fun (&#64;function_name, pars);  % set forgraound function(s)
&gt;&gt; myobj = myobj.set_bfun (&#64;function_name, pars); % set background function(s)</p>
<blockquote>
<div><p>:</p>
</div></blockquote>
<p>&gt;&gt; myobj = myobj.set_free (pfree);      % set which parameters are floating
&gt;&gt; myobj = myobj.set_bfree (bpfree);    % set which parameters are floating
&gt;&gt; [wfit,fitpars] = myobj.fit;          % perform fit</p>
</div></blockquote>
<p>This method fits function(s) of S(Q,w) as both the foreground and
the background function(s). For the format of the fit functions:
&lt;a href=”matlab:edit(‘example_sqw_spin_waves’);”&gt;Damped spin waves&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_sqw_flat_mode’);”&gt;Dispersionless excitations&lt;/a&gt;</p>
<p>See also multifit multifit_sqw</p>
</div></blockquote>
<blockquote>
<div><p>method_name = ‘multifit_sqw_sqw’
mfclass_name = ‘mfclass_Horace_sqw_sqw’
function_tag = ‘of S(Q,w) ‘</p>
<p>multifit_doc = fullfile(fileparts(which(‘multifit’)),’_docify’)
sqw_doc = fullfile(fileparts(which(‘mfclass_Horace’)),’_docify’)</p>
<p>doc_multifit_header = fullfile(multifit_doc,’doc_multifit_header.m’)
doc_fit_functions = fullfile(sqw_doc,’doc_multifit_sqw_sqw_fit_functions_for_sqw.m’)</p>
</div></blockquote>
<blockquote>
<div><blockquote>
<div><p>&lt;#file:&gt;  &lt;doc_fit_functions&gt;</p>
</div></blockquote>
<p>See also multifit multifit_sqw</p>
<p>&lt;#doc_end:&gt;</p>
</div></blockquote>
</dd></dl>

<hr class="docutils" />
<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.SQWDnDBase.save">
<span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.SQWDnDBase.save" title="Permalink to this definition"></a></dt>
<dd><p>Save a sqw object or array of sqw objects to a binary sqw file with
recommended version</p>
<blockquote>
<div><p>&gt;&gt; save (w)              % prompt for file
&gt;&gt; save (w, file)        % save to file with the name provided
&gt;&gt; save (w, file,loader) % save file using specific binary data</p>
<blockquote>
<div><blockquote>
<div><p>accessor</p>
</div></blockquote>
<p>(“-update” option, if provided with together
with loader will be ignored)</p>
</div></blockquote>
<dl class="simple">
<dt>&gt;&gt; save (w, file,[‘-parallel’<a href="#id36"><span class="problematic" id="id37">|</span></a>JobDispatcher])</dt><dd><p>combine file using parallel algorithm.
Useful and would works only if (when) pix
value of sqw object data is set up to the
instance of pix_combine_info class,
containing information on the partial
tmp files, written by filebased gen_sqw or
cut algorithm</p>
</dd>
<dt>&gt;&gt; save (w, file,’-update’) % if the target file exist, update it to</dt><dd><p>latest format if this is possible. If
update is possible, pixels in file will not be
overwritten.</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>Input:</dt><dd><p>w       sqw object
file    [optional] File for output. if none given, then prompted for a file</p>
<p>Note that if w is an array of sqw objects then file must be a cell
array of filenames of the same size.</p>
</dd>
</dl>
<p>Optional output:
cl – running instance of parallel cluster, used to combine multiple tmp</p>
<blockquote>
<div><blockquote>
<div><p>files together if pix field of sqw object contains pix_combine_into
and -parallel option or parallel cluster itself are provided as
inpout. Empty in any other case</p>
</div></blockquote>
<p>TODO: currently empty. May re-enable when parallel saving is
implemented properly</p>
</div></blockquote>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.SQWDnDBase.sqw_eval">
<span class="sig-name descname"><span class="pre">sqw_eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">sqwfunc</span></em>, <em class="sig-param"><span class="pre">pars</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.SQWDnDBase.sqw_eval" title="Permalink to this definition"></a></dt>
<dd><p>Calculate sqw for a model scattering function</p>
<blockquote>
<div><blockquote>
<div><p>&gt;&gt; wout = sqw_eval(win, sqwfunc, p)
&gt;&gt; wout = sqw_eval(___, ‘-all’)
&gt;&gt; wout = sqw_eval(___, ‘all’, true)
&gt;&gt; wout = sqw_eval(___, ‘-average’)
&gt;&gt; wout = sqw_eval(___, ‘average’, true)
&gt;&gt; sqw_eval(___, ‘outfile’, outfile)
&gt;&gt; wout = sqw_eval(___, ‘outfile’, outfile)
&gt;&gt; sqw_eval(__, ‘outfile’, outfile, ‘filebacked’, true)
&gt;&gt; wout = sqw_eval(__, ‘filebacked’, true)</p>
</div></blockquote>
<blockquote>
<div><dl>
<dt>obj        SQWDnDBase object (or array of objects) used</dt><dd><blockquote>
<div><p>as the source of hkle coordinates for sqwfunc:</p>
</div></blockquote>
<ul class="simple">
<li><p>for dnd this is the image axis bin centre coordinates</p></li>
<li><p>for sqw this is the pixel coordinates or their cell
average.</p></li>
</ul>
</dd>
<dt>sqwfunc     Handle to function that calculates S(Q, w)</dt><dd><dl>
<dt>Most commonly used form is:</dt><dd><blockquote>
<div><p>weight = sqwfunc (qh, qk, ql, en, p)</p>
</div></blockquote>
<dl>
<dt>where</dt><dd><p>qh,qk,ql,en Arrays containing the coordinates of a set of points
p           Vector of parameters needed by dispersion function</p>
<blockquote>
<div><p>e.g. [A, js, gam] as intensity, exchange, lifetime</p>
</div></blockquote>
<p>weight      Array containing calculated spectral weight</p>
</dd>
</dl>
</dd>
<dt>More general form is:</dt><dd><blockquote>
<div><p>weight = sqwfunc (qh, qk, ql, en, p, c1, c2, ..)</p>
</div></blockquote>
<dl class="simple">
<dt>where</dt><dd><dl class="simple">
<dt>p           Typically a vector of parameters that we might want</dt><dd><p>to fit in a least-squares algorithm</p>
</dd>
<dt>c1, c2, …   Other constant parameters e.g. file name for look-up</dt><dd><p>table</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>pars       Arguments needed by the function. Most commonly, a vector of parameter</dt><dd><p>values e.g. [A, js, gam] as intensity, exchange, lifetime. If a more general
set of parameters is required by the function, then
package these into a cell array and pass that as pars. In the example
above then pars = {p, c1, c2, …}</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><dl>
<dt>outfile    If present, the outputs will be written to the file of the given</dt><dd><p>name/path.
If numel(win) &gt; 1, outfile must either be omitted or be a cell
array of file paths with equal number of elements as win.</p>
</dd>
<dt>all        If true, requests that the calculated sqw be returned over</dt><dd><p>the whole of the domain of the input dataset. If false, then
the function will be returned only at those points of the dataset
that contain <a href="#id53"><span class="problematic" id="id54">data_</span></a>.</p>
<blockquote>
<div><p>Applies only to input with no pixel information - it is ignored if</p>
</div></blockquote>
<p>full sqw object.
[default = false]</p>
</dd>
<dt>average    If true, requests that the calculated sqw be computed for the</dt><dd><p>average values of h, k, l of the pixels in a bin, not for each
pixel individually. Reduces cost of expensive calculations.
Applies only to the case of sqw object with pixel information
- it is ignored if dnd type object.
[default = false]</p>
</dd>
<dt>filebacked  If true, the result of the function will be saved to file and</dt><dd><p>the output will be a file path. If no <cite>outfile</cite> is specified,
a unique path within <cite>tempdir()</cite> will be generated.
Default is false.</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Note: all optional string input parameters can be truncated up to minimal</dt><dd><p>difference between them e.g. routine would accept ‘al’ and
‘av’, ‘ave’, ‘aver’ etc….</p>
</dd>
</dl>
<blockquote>
<div><dl class="simple">
<dt>obj        If <cite>filebacked</cite> is false, an sqw object or array of sqw objects.</dt><dd><p>If <cite>filebacked</cite> is true, a file path or cell array of file paths.
Output argument must be specified if <cite>outfile</cite> not given.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
</dd></dl>

<hr class="docutils" />
<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.SQWDnDBase.sqw_eval_nopix">
<span class="sig-name descname"><span class="pre">sqw_eval_nopix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">sqwfunc</span></em>, <em class="sig-param"><span class="pre">all_bins</span></em>, <em class="sig-param"><span class="pre">pars</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.SQWDnDBase.sqw_eval_nopix" title="Permalink to this definition"></a></dt>
<dd><p>SQW_EVAL_NOPIX</p>
<blockquote>
<div><p>Helper function for sqw eval executed on a pixel-less object (i.e. DnD or SQW with no pixels
Called by <cite>sqw_eval_</cite> defined in sqw/DnDBase</p>
<blockquote>
<div><dl class="simple">
<dt>obj        Dataset (or array of datasets) that provides the axes and points</dt><dd><p>for the calculation</p>
</dd>
</dl>
<p>sqwfunc     Handle to function that calculates S(Q,w)
all_bins    Boolean flag wither to apply function to all bins or only those contaiing data
pars       Arguments needed by the function.</p>
</div></blockquote>
</div></blockquote>
</dd></dl>

<hr class="docutils" />
<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.SQWDnDBase.unary_op_manager">
<span class="sig-name descname"><span class="pre">unary_op_manager</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em>, <em class="sig-param"><span class="pre">unary_op</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.SQWDnDBase.unary_op_manager" title="Permalink to this definition"></a></dt>
<dd><p>Implements a unary operation for objects with a signal and a variance array.</p>
<blockquote>
<div><p>&gt;&gt; w = unary_op_manager(w1, unary_op)</p>
</div></blockquote>
<p>Most unary operations on MATLAB double arrays are permitted (e.g. acos,
sqrt, log10…) and are applied element by element to the signal and
variance arrays.</p>
<section id="id38">
<h3>Input:<a class="headerlink" href="#id38" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
<p>unary_op    Function handle to the unary operator.</p>
</div></blockquote>
</section>
<section id="id39">
<h3>Output:<a class="headerlink" href="#id39" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
<p>NOTES:
This is a generic template method - works for any class (including sigvar)
but the indicated blocks may need to be edited for a particular class.</p>
<p>Requires that objects have the following methods to find the size of the
public signal and variance arrays, create a sigvar object from those
arrays, and set them from another sigvar object.</p>
<blockquote>
<div><dl class="simple">
<dt>&gt;&gt; sz = sigvar_size(obj)    % Returns size of public signal and variance</dt><dd><p>% arrays</p>
</dd>
<dt>&gt;&gt; w = sigvar(obj)          % Create a sigvar object from the public</dt><dd><p>% signal and variance arrays</p>
</dd>
<dt>&gt;&gt; obj = sigvar_set(obj,w)  % Set signal and variance in an object from</dt><dd><p>% those in a sigvar object</p>
</dd>
</dl>
</div></blockquote>
</section>
</dd></dl>

</dd>
</dl>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.disp2sqw_eval">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">disp2sqw_eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">dispreln</span></em>, <em class="sig-param"><span class="pre">pars</span></em>, <em class="sig-param"><span class="pre">fwhh</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.disp2sqw_eval" title="Permalink to this definition"></a></dt>
<dd><p>Calculate sqw for a model scattering function</p>
<blockquote>
<div><p>&gt;&gt; wout = disp2sqw_eval(win,dispreln,pars,fwhh,varargin)</p>
</div></blockquote>
<section id="id40">
<h3>Input:<a class="headerlink" href="#id40" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl>
<dt>win         Dataset, or array of datasets, that provides the axes and points</dt><dd><p>for the calculation</p>
</dd>
<dt>dispreln    Handle to function that calculates the dispersion relation w(Q) and</dt><dd><p>spectral weight, s(Q)
Must have form:</p>
<blockquote>
<div><blockquote>
<div><p>[w,s] = dispreln (qh,qk,ql,p)</p>
</div></blockquote>
<dl class="simple">
<dt>where</dt><dd><dl class="simple">
<dt>qh,qk,ql    Arrays containing the coordinates of a set of points</dt><dd><p>in reciprocal lattice units</p>
</dd>
<dt>p           Vector of parameters needed by dispersion function</dt><dd><p>e.g. [A,js,gam] as intensity, exchange, lifetime</p>
</dd>
<dt>w           Array of corresponding energies, or, if more than</dt><dd><p>one dispersion relation, a cell array of arrays.</p>
</dd>
<dt>s           Array of spectral weights, or, if more than</dt><dd><p>one dispersion relation, a cell array of arrays.</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>More general form is:</dt><dd><blockquote>
<div><p>[w,s] = dispreln (qh,qk,ql,p,c1,c2,..)</p>
</div></blockquote>
<dl class="simple">
<dt>where</dt><dd><dl class="simple">
<dt>p           Typically a vector of parameters that we might want</dt><dd><p>to fit in a least-squares algorithm</p>
</dd>
<dt>c1,c2,…   Other constant parameters e.g. file name for look-up</dt><dd><p>table.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>pars        Arguments needed by the function. Most commonly, a vector of parameter</dt><dd><p>values e.g. [A,js,gam] as intensity, exchange, lifetime. If a more general
set of parameters is required by the function, then
package these into a cell array and pass that as pars. In the example
above then pars = {p, c1, c2, …}</p>
</dd>
<dt>fwhh       Parametrizes the resolution function. There are three</dt><dd><blockquote>
<div><p>possible input values of fwhh:</p>
</div></blockquote>
<dl>
<dt>double              A single FWHM value determines the FWHM of the</dt><dd><p>Gaussian resolution function</p>
</dd>
<dt>function_handle     A function that produces the FWHM value as a</dt><dd><p>function of energy transfer, it has to have the
following simple header (where omega can be a row
vector of energies:</p>
<blockquote>
<div><p>dE = resfun(omega)</p>
</div></blockquote>
</dd>
<dt>function_handle     A function handle of a function with two input</dt><dd><dl class="simple">
<dt>parameters with the following header:</dt><dd><p>I = shapefun(Emat,omega)</p>
</dd>
</dl>
<p>where Emat is a matrix with dimensions of [nQ nE]
and omega is a column vector with nQ elements. The
shapefun produces a peakshape for every Q point
centered at the given omega and normalized to one.
The output I has the same dimensions as the
input Emat.</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>Optional arguments: (varargin)</p>
<blockquote>
<div><dl>
<dt>‘-al[l]’  Requests that the calculated sqw be returned over</dt><dd><p>the whole of the domain of the input dataset. If not given, then
the function will be returned only at those points of the dataset
that contain data.
Applies only to input with no pixel information - it is ignored if
full sqw object.</p>
</dd>
<dt>‘-av[erage]’ Requests that the calculated sqw be computed for the</dt><dd><p>average values of h,k,l of the pixels in a bin, not for each
pixel individually. Reduces cost of expensive calculations.</p>
<blockquote>
<div><p>Applies only to the case of sqw object with pixel information - it is</p>
</div></blockquote>
<p>ignored if dnd type object.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id41">
<h3>Output:<a class="headerlink" href="#id41" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>wout        Output dataset or array of datasets</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.equal_to_tol">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">equal_to_tol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em>, <em class="sig-param"><span class="pre">w2</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.equal_to_tol" title="Permalink to this definition"></a></dt>
<dd><p>Check if two sqw objects are equal to a given tolerance</p>
<blockquote>
<div><p>&gt;&gt; ok = equal_to_tol (a, b)
&gt;&gt; ok = equal_to_tol (a, b, tol)
&gt;&gt; ok = equal_to_tol (…, keyword1, val1, keyword2, val2,…)
&gt;&gt; [ok, mess] = equal_to_tol (…)</p>
</div></blockquote>
<dl class="simple">
<dt>Class specific version of the generic equal_to_tol that by default</dt><dd><ol class="arabic simple">
<li><p>assumes NaN are equivalent (see option ‘nan_equal’), and</p></li>
<li><p>ignores the order of pixels within a bin as the order is irrelevant
(change the default with option ‘reorder’)</p></li>
</ol>
</dd>
</dl>
<p>In addition, it is possible to check the contents of just a random
fraction of non-empty bins (see option ‘fraction’) in order to speed up
the comparison of large objects.</p>
<section id="id42">
<h3>Input:<a class="headerlink" href="#id42" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w1,w2   Test objects (scalar objects, or arrays of objects with same sizes)</p>
<dl>
<dt>tol     Tolerance criterion for numeric arrays (Default: [0,0] i.e. equality)</dt><dd><dl class="simple">
<dt>It has the form: [abstol, reltol] where</dt><dd><p>abstol     absolute tolerance (&gt;=0; if =0 equality required)
reltol     relative tolerance (&gt;=0; if =0 equality required)</p>
</dd>
</dl>
<p>If either criterion is satified then equality within tolerance
is accepted.</p>
<blockquote>
<div><dl class="simple">
<dt>Examples:</dt><dd><p>[1e-4, 1e-6]    absolute 1e-4 or relative 1e-6 required
[1e-4, 0]       absolute 1e-4 required
[0, 1e-6]       relative 1e-6 required
[0, 0]          equality required
0               equivalent to [0,0]</p>
</dd>
</dl>
</div></blockquote>
<p>For backwards compatibility, a scalar tolerance can be given
where the sign determines absolute or relative tolerance</p>
<blockquote>
<div><blockquote>
<div><p>+ve : absolute tolerance  abserr = abs(a-b)
-ve : relative tolerance  relerr = abs(a-b)/max(abs(a),abs(b))</p>
</div></blockquote>
<dl class="simple">
<dt>Examples:</dt><dd><p>1e-4            absolute tolerance, equivalent to [1e-4, 0]
-1e-6           relative tolerance, equivalent to [0, 1e-6]</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>[To apply an absolute as well as a relative tolerance with a</dt><dd><p>scalar negative value, set the value of the legacy keyword</p>
</dd>
</dl>
<p>‘min_denominator’ (see below)]</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>Valid keywords are:</dt><dd><p>‘nan_equal’      Treat NaNs as equal (true or false; default=true)</p>
<dl>
<dt>‘ignore_str’     Ignore the length and content of strings or cell arrays</dt><dd><p>of strings (true or false; default=false)</p>
</dd>
<dt>‘reorder’        Ignore the order of pixels within each bin</dt><dd><dl class="simple">
<dt>(true or false; default=true)</dt><dd><p>Only applies if sqw-type object</p>
</dd>
</dl>
</dd>
<dt>‘fraction’       Compare pixels in only a fraction of the non-empty bins</dt><dd><dl class="simple">
<dt>(0&lt;= fracton &lt;= 1; default=1 i.e. test all bins)</dt><dd><p>Only applies if sqw-type object</p>
</dd>
</dl>
</dd>
<dt>‘-ignore_date’   (provided without additional values, so its presence in</dt><dd><blockquote>
<div><blockquote>
<div><p>the sequence of keywords means true). If provided,
ignore file creation date stored in main header.</p>
</div></blockquote>
<p>The reorder and fraction options are available because the order of the</p>
</div></blockquote>
<p>pixels within the pix array for a given bin is unimportant. Reordering
takes time, however, so the option to test on a few bins is given.</p>
</dd>
</dl>
</dd>
</dl>
</section>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.sqw_eval">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">sqw_eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">sqwfunc</span></em>, <em class="sig-param"><span class="pre">pars</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.sqw_eval" title="Permalink to this definition"></a></dt>
<dd><p>Calculate sqw for a model scattering function</p>
<blockquote>
<div><blockquote>
<div><p>&gt;&gt; wout = sqw_eval(win, sqwfunc, p)
&gt;&gt; wout = sqw_eval(___, ‘-all’)
&gt;&gt; wout = sqw_eval(___, ‘all’, true)
&gt;&gt; wout = sqw_eval(___, ‘-average’)
&gt;&gt; wout = sqw_eval(___, ‘average’, true)
&gt;&gt; sqw_eval(___, ‘outfile’, outfile)
&gt;&gt; wout = sqw_eval(___, ‘outfile’, outfile)
&gt;&gt; sqw_eval(__, ‘outfile’, outfile, ‘filebacked’, true)
&gt;&gt; wout = sqw_eval(__, ‘filebacked’, true)</p>
</div></blockquote>
<blockquote>
<div><dl>
<dt>obj        SQWDnDBase object (or array of objects) used</dt><dd><blockquote>
<div><p>as the source of hkle coordinates for sqwfunc:</p>
</div></blockquote>
<ul class="simple">
<li><p>for dnd this is the image axis bin centre coordinates</p></li>
<li><p>for sqw this is the pixel coordinates or their cell
average.</p></li>
</ul>
</dd>
<dt>sqwfunc     Handle to function that calculates S(Q, w)</dt><dd><dl>
<dt>Most commonly used form is:</dt><dd><blockquote>
<div><p>weight = sqwfunc (qh, qk, ql, en, p)</p>
</div></blockquote>
<dl>
<dt>where</dt><dd><p>qh,qk,ql,en Arrays containing the coordinates of a set of points
p           Vector of parameters needed by dispersion function</p>
<blockquote>
<div><p>e.g. [A, js, gam] as intensity, exchange, lifetime</p>
</div></blockquote>
<p>weight      Array containing calculated spectral weight</p>
</dd>
</dl>
</dd>
<dt>More general form is:</dt><dd><blockquote>
<div><p>weight = sqwfunc (qh, qk, ql, en, p, c1, c2, ..)</p>
</div></blockquote>
<dl class="simple">
<dt>where</dt><dd><dl class="simple">
<dt>p           Typically a vector of parameters that we might want</dt><dd><p>to fit in a least-squares algorithm</p>
</dd>
<dt>c1, c2, …   Other constant parameters e.g. file name for look-up</dt><dd><p>table</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>pars       Arguments needed by the function. Most commonly, a vector of parameter</dt><dd><p>values e.g. [A, js, gam] as intensity, exchange, lifetime. If a more general
set of parameters is required by the function, then
package these into a cell array and pass that as pars. In the example
above then pars = {p, c1, c2, …}</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><dl>
<dt>outfile    If present, the outputs will be written to the file of the given</dt><dd><p>name/path.
If numel(win) &gt; 1, outfile must either be omitted or be a cell
array of file paths with equal number of elements as win.</p>
</dd>
<dt>all        If true, requests that the calculated sqw be returned over</dt><dd><p>the whole of the domain of the input dataset. If false, then
the function will be returned only at those points of the dataset
that contain <a href="#id55"><span class="problematic" id="id56">data_</span></a>.</p>
<blockquote>
<div><p>Applies only to input with no pixel information - it is ignored if</p>
</div></blockquote>
<p>full sqw object.
[default = false]</p>
</dd>
<dt>average    If true, requests that the calculated sqw be computed for the</dt><dd><p>average values of h, k, l of the pixels in a bin, not for each
pixel individually. Reduces cost of expensive calculations.
Applies only to the case of sqw object with pixel information
- it is ignored if dnd type object.
[default = false]</p>
</dd>
<dt>filebacked  If true, the result of the function will be saved to file and</dt><dd><p>the output will be a file path. If no <cite>outfile</cite> is specified,
a unique path within <cite>tempdir()</cite> will be generated.
Default is false.</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Note: all optional string input parameters can be truncated up to minimal</dt><dd><p>difference between them e.g. routine would accept ‘al’ and
‘av’, ‘ave’, ‘aver’ etc….</p>
</dd>
</dl>
<blockquote>
<div><dl class="simple">
<dt>obj        If <cite>filebacked</cite> is false, an sqw object or array of sqw objects.</dt><dd><p>If <cite>filebacked</cite> is true, a file path or cell array of file paths.
Output argument must be specified if <cite>outfile</cite> not given.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
</dd></dl>

<hr class="docutils" />
<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.mask_points">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">mask_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.mask_points" title="Permalink to this definition"></a></dt>
<dd><p>TODO: Does not look like this function should be here</p>
<p>Determine the points to keep on the basis of ranges and mask array.</p>
<blockquote>
<div><p>&gt;&gt; sel = mask_points (win, ‘keep’, xkeep, ‘remove’, xremove, ‘mask’, mask)</p>
</div></blockquote>
<p>or any selection (in any order) of the keyword-argument pairs e.g.</p>
<blockquote>
<div><p>&gt;&gt; sel = mask_points (win, ‘mask’, mask, ‘remove’, xremove)</p>
</div></blockquote>
<section id="id43">
<h3>Input:<a class="headerlink" href="#id43" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>win     Input sqw object</p>
<dl>
<dt>xkeep   Ranges of display axes to retain for fitting. A range is specified by an array</dt><dd><p>of numbers which define a hypercube.
For example in case of two dimensions:</p>
<blockquote>
<div><p>[xlo, xhi, ylo, yhi]</p>
</div></blockquote>
<dl>
<dt>or in the case of n-dimensions:</dt><dd><blockquote>
<div><p>[x1_lo, x1_hi, x2_lo, x2_hi,…, xn_lo, xn_hi]</p>
</div></blockquote>
<dl class="simple">
<dt>e.g. 1D: [50,70]</dt><dd><p>2D: [1,2,130,160]</p>
</dd>
</dl>
</dd>
<dt>More than one range can be defined in rows,</dt><dd><blockquote>
<div><p>[Range_1; Range_2; Range_3;…; Range_m]</p>
</div></blockquote>
<p>where each of the ranges are given in the format above.</p>
</dd>
</dl>
</dd>
</dl>
<p>xremove Ranges of display axes to remove from fitting.</p>
<dl>
<dt>mask    Mask array of same number of elements as data array: 1 to keep, 0 to remove</dt><dd><blockquote>
<div><p>Note: mask will be applied to the stored data array</p>
</div></blockquote>
<p>according as the projection axes, not the display axes.
Thus permuting the display axes does not alter the
effect of masking the data. The mask array works
consistently with the input required by the mask method.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id44">
<h3>Output:<a class="headerlink" href="#id44" title="Permalink to this heading"></a></h3>
<blockquote>
<div><blockquote>
<div><p>sel     Mask array of same shape as <a href="#id57"><span class="problematic" id="id58">data_</span></a>. true for bins to keep, false to discard.</p>
</div></blockquote>
<p>Advanced use: in addition the following two arguments, if present, suppress failure or the
display of informational messges. Instead, the messages are returned to be used as desired.</p>
<blockquote>
<div><p>ok      =true if worked, =false if error</p>
<p>mess    messages: if ok=true then informational or warning, if ok=false then the error message</p>
</div></blockquote>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.sqw_eval_nopix">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">sqw_eval_nopix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">sqwfunc</span></em>, <em class="sig-param"><span class="pre">all_bins</span></em>, <em class="sig-param"><span class="pre">pars</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.sqw_eval_nopix" title="Permalink to this definition"></a></dt>
<dd><p>SQW_EVAL_NOPIX</p>
<blockquote>
<div><p>Helper function for sqw eval executed on a pixel-less object (i.e. DnD or SQW with no pixels
Called by <cite>sqw_eval_</cite> defined in sqw/DnDBase</p>
<blockquote>
<div><dl class="simple">
<dt>obj        Dataset (or array of datasets) that provides the axes and points</dt><dd><p>for the calculation</p>
</dd>
</dl>
<p>sqwfunc     Handle to function that calculates S(Q,w)
all_bins    Boolean flag wither to apply function to all bins or only those contaiing data
pars       Arguments needed by the function.</p>
</div></blockquote>
</div></blockquote>
</dd></dl>

</section>
<hr class="docutils" />
<section id="module-sqw.&#64;Experiment">
<span id="experiment-class"></span><h2><a class="toc-backref" href="#id49" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">Experiment</span></code> class</a><a class="headerlink" href="#module-sqw.@Experiment" title="Permalink to this heading"></a></h2>
<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.get_efix">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;Experiment.</span></span><span class="sig-name descname"><span class="pre">get_efix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.get_efix" title="Permalink to this definition"></a></dt>
<dd><p>Return array of incident energies from all runs, contributing to
experiment.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.upgrade_legacy_alignment">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;Experiment.</span></span><span class="sig-name descname"><span class="pre">upgrade_legacy_alignment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">deal_info</span></em>, <em class="sig-param"><span class="pre">alatt</span></em>, <em class="sig-param"><span class="pre">angdeg</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.upgrade_legacy_alignment" title="Permalink to this definition"></a></dt>
<dd><p>UPGRADE_LEGACY_ALIGNMENT Change fields in the experiment with correction
to remove legacy alignment applied to the crystal earlier and apply
modern alignment to it.</p>
<p>Inputs:
obj    – legacy realigned dnd object. Algorithm throws if the object has</p>
<blockquote>
<div><p>not been realigned using legacy algorithm.</p>
</div></blockquote>
<dl class="simple">
<dt>deal_info</dt><dd><dl class="simple">
<dt>–  instance of crystal_alignment_info class, containing information</dt><dd><p>about dealignment of the legacy-aligned crystal</p>
</dd>
</dl>
</dd>
</dl>
<p>Optional
alatt   – lattice parameters with values for aligned lattice to be set.
angdeg  – lattice angles with values for aligned lattice to be set.</p>
<blockquote>
<div><p>If one is present, another one have to be present.
If these values are missing, assumes that the lattice have not
been changed.</p>
</div></blockquote>
<p>Outputs:
wout    – dnd object according to the new alignment algorithm.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.remove_legacy_alignment">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;Experiment.</span></span><span class="sig-name descname"><span class="pre">remove_legacy_alignment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">deal_info</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.remove_legacy_alignment" title="Permalink to this definition"></a></dt>
<dd><p>REMOVE_LEGACY_ALIGNMENT Change fields in the experiment with correction
to remove legacy alignment applied to the crystal earlier.</p>
<p>Inputs:
obj    – legacy realigned dnd object. Algorithm throws if the object has</p>
<blockquote>
<div><p>not been realigned using legacy algorithm.</p>
</div></blockquote>
<dl class="simple">
<dt>deal_info</dt><dd><dl class="simple">
<dt>– instance of crystal_alignment_info class, containing information</dt><dd><p>about de-alignment</p>
</dd>
</dl>
</dd>
</dl>
<p>Outputs:
obj     – Experiment object with alignment removed</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.set_mod_pulse">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;Experiment.</span></span><span class="sig-name descname"><span class="pre">set_mod_pulse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">pulse_model</span></em>, <em class="sig-param"><span class="pre">pm_par</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.set_mod_pulse" title="Permalink to this definition"></a></dt>
<dd><p>Set moderator pulse model on all unique instruments, contributed in the
experiment
Input:
——</p>
<blockquote>
<div><p>obj         Experiment object
pulse_model Pulse shape model name e.g. ‘ikcarp’
pp          Pulse shape parameters: row vector for a single set of parameters</p>
<blockquote>
<div><p>or a 2D array, one row per spe data set for each instrument
of the sqw object(s).</p>
</div></blockquote>
</div></blockquote>
<section id="id45">
<h3>Output:<a class="headerlink" href="#id45" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>obj         Modified experiment</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.Experiment">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sqw.&#64;Experiment.</span></span><span class="sig-name descname"><span class="pre">Experiment</span></span><a class="headerlink" href="#sqw.@Experiment.Experiment" title="Permalink to this definition"></a></dt>
<dd><p>EXPERIMENT Container object for all data describing the Experiment</p>
<div class="members docutils container">
<dl>
<dt>Method Summary</dt><dd><dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.Experiment.change_crystal">
<span class="sig-name descname"><span class="pre">change_crystal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">alignment_info</span></em>, <em class="sig-param"><span class="pre">proj</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.Experiment.change_crystal" title="Permalink to this definition"></a></dt>
<dd><dl>
<dt>Change fields in the experiment with correction related to change crystal</dt><dd><p>lattice parameters and orientation</p>
<blockquote>
<div><p>&gt;&gt; obj=change_crystal(obj,alignment_info)</p>
</div></blockquote>
</dd>
</dl>
<p>obj            – initialized instance of Experiment object</p>
<dl>
<dt>alignment_info – helper class, containing the information</dt><dd><blockquote>
<div><p>about the crystal alignment, returned by refine_crystal
routine. Type:</p>
</div></blockquote>
<p>&gt;&gt; help refine_crystal  for more details.</p>
</dd>
<dt>proj            – the instance of the projection, which converts pixels</dt><dd><p>from</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.Experiment.get_efix">
<span class="sig-name descname"><span class="pre">get_efix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.Experiment.get_efix" title="Permalink to this definition"></a></dt>
<dd><p>Return array of incident energies from all runs, contributing to
experiment.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.Experiment.remove_legacy_alignment">
<span class="sig-name descname"><span class="pre">remove_legacy_alignment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">deal_info</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.Experiment.remove_legacy_alignment" title="Permalink to this definition"></a></dt>
<dd><p>REMOVE_LEGACY_ALIGNMENT Change fields in the experiment with correction
to remove legacy alignment applied to the crystal earlier.</p>
<p>Inputs:
obj    – legacy realigned dnd object. Algorithm throws if the object has</p>
<blockquote>
<div><p>not been realigned using legacy algorithm.</p>
</div></blockquote>
<dl class="simple">
<dt>deal_info</dt><dd><dl class="simple">
<dt>– instance of crystal_alignment_info class, containing information</dt><dd><p>about de-alignment</p>
</dd>
</dl>
</dd>
</dl>
<p>Outputs:
obj     – Experiment object with alignment removed</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.Experiment.set_instrument">
<span class="sig-name descname"><span class="pre">set_instrument</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">instr_or_fun</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.Experiment.set_instrument" title="Permalink to this definition"></a></dt>
<dd><p>add or reset instrument, related to the given experiment class</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.Experiment.set_mod_pulse">
<span class="sig-name descname"><span class="pre">set_mod_pulse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">pulse_model</span></em>, <em class="sig-param"><span class="pre">pm_par</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.Experiment.set_mod_pulse" title="Permalink to this definition"></a></dt>
<dd><p>Set moderator pulse model on all unique instruments, contributed in the
experiment
Input:
——</p>
<blockquote>
<div><p>obj         Experiment object
pulse_model Pulse shape model name e.g. ‘ikcarp’
pp          Pulse shape parameters: row vector for a single set of parameters</p>
<blockquote>
<div><p>or a 2D array, one row per spe data set for each instrument
of the sqw object(s).</p>
</div></blockquote>
</div></blockquote>
<section id="id46">
<h3>Output:<a class="headerlink" href="#id46" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>obj         Modified experiment</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.Experiment.upgrade_legacy_alignment">
<span class="sig-name descname"><span class="pre">upgrade_legacy_alignment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">deal_info</span></em>, <em class="sig-param"><span class="pre">alatt</span></em>, <em class="sig-param"><span class="pre">angdeg</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.Experiment.upgrade_legacy_alignment" title="Permalink to this definition"></a></dt>
<dd><p>UPGRADE_LEGACY_ALIGNMENT Change fields in the experiment with correction
to remove legacy alignment applied to the crystal earlier and apply
modern alignment to it.</p>
<p>Inputs:
obj    – legacy realigned dnd object. Algorithm throws if the object has</p>
<blockquote>
<div><p>not been realigned using legacy algorithm.</p>
</div></blockquote>
<dl class="simple">
<dt>deal_info</dt><dd><dl class="simple">
<dt>–  instance of crystal_alignment_info class, containing information</dt><dd><p>about dealignment of the legacy-aligned crystal</p>
</dd>
</dl>
</dd>
</dl>
<p>Optional
alatt   – lattice parameters with values for aligned lattice to be set.
angdeg  – lattice angles with values for aligned lattice to be set.</p>
<blockquote>
<div><p>If one is present, another one have to be present.
If these values are missing, assumes that the lattice have not
been changed.</p>
</div></blockquote>
<p>Outputs:
wout    – dnd object according to the new alignment algorithm.</p>
</dd></dl>

</dd>
</dl>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.change_crystal">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;Experiment.</span></span><span class="sig-name descname"><span class="pre">change_crystal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">alignment_info</span></em>, <em class="sig-param"><span class="pre">proj</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.change_crystal" title="Permalink to this definition"></a></dt>
<dd><dl>
<dt>Change fields in the experiment with correction related to change crystal</dt><dd><p>lattice parameters and orientation</p>
<blockquote>
<div><p>&gt;&gt; obj=change_crystal(obj,alignment_info)</p>
</div></blockquote>
</dd>
</dl>
<p>obj            – initialized instance of Experiment object</p>
<dl>
<dt>alignment_info – helper class, containing the information</dt><dd><blockquote>
<div><p>about the crystal alignment, returned by refine_crystal
routine. Type:</p>
</div></blockquote>
<p>&gt;&gt; help refine_crystal  for more details.</p>
</dd>
<dt>proj            – the instance of the projection, which converts pixels</dt><dd><p>from</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.set_instrument">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;Experiment.</span></span><span class="sig-name descname"><span class="pre">set_instrument</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">instr_or_fun</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.set_instrument" title="Permalink to this definition"></a></dt>
<dd><p>add or reset instrument, related to the given experiment class</p>
</dd></dl>

</section>
<section id="pixeldata-class">
<h2><a class="toc-backref" href="#id50" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">PixelData</span></code> class</a><a class="headerlink" href="#pixeldata-class" title="Permalink to this heading"></a></h2>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Contributing.html" class="btn btn-neutral float-left" title="Contributing to Horace" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="General_disclaimer.html" class="btn btn-neutral float-right" title="General disclaimer" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2006-2023, STFC RAL.
      <span class="lastupdated">Last updated on Nov 10, 2023, 9:57:54 PM.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
<br><br>
<a href="https://github.com/pace-neutrons/Horace/edit/master/documentation/user_docs/docs/API_Reference.rst">Click here to edit</a> or <a href="https://github.com/pace-neutrons/Horace/edit/master/documentation/user_docs/docs/new_page.rst">Click here to add new page</a> (requires <a href="https://github.com/login">GitHub account</a>).
<br>
For more info on editing <a href="Contributing.html">click here</a>.


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>