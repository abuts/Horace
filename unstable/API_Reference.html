<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>API Reference &mdash; Horace  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="General disclaimer" href="General_disclaimer.html" />
    <link rel="prev" title="Contributing to Horace" href="Contributing.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Horace
              <img src="_static/150px-Quintus_Horatius_Flaccus.jpg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">Introduction and Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="User_guide.html">User’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="Horace_manual.html">Horace Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="Citing.html">Citing Horace</a></li>
<li class="toctree-l1"><a class="reference internal" href="Developers.html">For Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="Contributing.html">Contributing to Horace</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-sqw.&#64;SQWDnDBase"><code class="docutils literal notranslate"><span class="pre">SQWDndBase</span></code> class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-sqw.&#64;Experiment"><code class="docutils literal notranslate"><span class="pre">Experiment</span></code> class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pixeldata-class"><code class="docutils literal notranslate"><span class="pre">PixelData</span></code> class</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="General_disclaimer.html">General disclaimer</a></li>
<li class="toctree-l1"><a class="reference internal" href="Privacy_policy.html">Privacy Policy</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Horace</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">API Reference</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/API_Reference.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="api-reference">
<h1><a class="toc-backref" href="#id87" role="doc-backlink">API Reference</a><a class="headerlink" href="#api-reference" title="Permalink to this heading"></a></h1>
<nav class="contents" id="table-of-contents">
<p class="topic-title">Table of Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#api-reference" id="id87">API Reference</a></p>
<ul>
<li><p><a class="reference internal" href="#module-sqw.&#64;SQWDnDBase" id="id88"><code class="docutils literal notranslate"><span class="pre">SQWDndBase</span></code> class</a></p></li>
<li><p><a class="reference internal" href="#module-sqw.&#64;Experiment" id="id89"><code class="docutils literal notranslate"><span class="pre">Experiment</span></code> class</a></p></li>
<li><p><a class="reference internal" href="#pixeldata-class" id="id90"><code class="docutils literal notranslate"><span class="pre">PixelData</span></code> class</a></p></li>
</ul>
</li>
</ul>
</nav>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">API Index</span></a></p></li>
</ul>
<section id="module-sqw.&#64;SQWDnDBase">
<span id="sqwdndbase-class"></span><h2><a class="toc-backref" href="#id88" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">SQWDndBase</span></code> class</a><a class="headerlink" href="#module-sqw.@SQWDnDBase" title="Permalink to this heading"></a></h2>
<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.mrdivide">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">mrdivide</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em>, <em class="sig-param"><span class="pre">w2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.mrdivide" title="Permalink to this definition"></a></dt>
<dd><p>Implements w1 / w2 for objects</p>
<blockquote>
<div><p>&gt;&gt; w = w1 / w2</p>
</div></blockquote>
<section id="input">
<h3>Input:<a class="headerlink" href="#input" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl>
<dt>w1, w2      Objects on which the binary operation is to be performed.</dt><dd><p>One of these can be a Matlab double (i.e. double precision)
array, in which case the variance array is taken to be zero.</p>
<p>If w1, w2 are scalar objects with the same signal array sizes:
- The operation is performed element-by-element.</p>
<p>If one of w1 or w2 is a double array (and the other is a
scalar object):
- If a scalar, apply to each element of the object signal.
- If it is an array of the same size as the object signal</p>
<blockquote>
<div><p>array, apply the operation element by element.</p>
</div></blockquote>
<p>If one or both of w1 and w2 are arrays of objects:
- If objects have same array sizes, the binary operation is</p>
<blockquote>
<div><p>applied object element-by-object element.</p>
</div></blockquote>
<ul class="simple">
<li><p>If one of the objects is scalar (i.e. only one object),</p></li>
</ul>
<blockquote>
<div><p>then it is applied by the binary operation to each object
in the other array.</p>
</div></blockquote>
<p>If one of w1, w2 is an array of objects and the other is a
double array:
- If the double is a scalar, it is applied to every object</p>
<blockquote>
<div><p>in the array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with the same size as the object</p></li>
</ul>
<blockquote>
<div><p>array, then each element is applied as a scalar to the
corresponding object in the object array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with larger size than the object</p></li>
</ul>
<blockquote>
<div><p>array, then the array is resolved into a stack of arrays,
where the stack has the same size as the object array, and
the each array in the stack is applied to the corresponding
object in the object array. [Note that for this operation
to be valid, each object must have the same signal array
size.]</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
</section>
<section id="output">
<h3>Output:<a class="headerlink" href="#output" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.mldivide">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">mldivide</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em>, <em class="sig-param"><span class="pre">w2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.mldivide" title="Permalink to this definition"></a></dt>
<dd><p>Implements w1 w2 for objects</p>
<blockquote>
<div><p>&gt;&gt; w = w1 w2</p>
</div></blockquote>
<section id="id1">
<h3>Input:<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl>
<dt>w1, w2      Objects on which the binary operation is to be performed.</dt><dd><p>One of these can be a Matlab double (i.e. double precision)
array, in which case the variance array is taken to be zero.</p>
<p>If w1, w2 are scalar objects with the same signal array sizes:
- The operation is performed element-by-element.</p>
<p>If one of w1 or w2 is a double array (and the other is a
scalar object):
- If a scalar, apply to each element of the object signal.
- If it is an array of the same size as the object signal</p>
<blockquote>
<div><p>array, apply the operation element by element.</p>
</div></blockquote>
<p>If one or both of w1 and w2 are arrays of objects:
- If objects have same array sizes, the binary operation is</p>
<blockquote>
<div><p>applied object element-by-object element.</p>
</div></blockquote>
<ul class="simple">
<li><p>If one of the objects is scalar (i.e. only one object),</p></li>
</ul>
<blockquote>
<div><p>then it is applied by the binary operation to each object
in the other array.</p>
</div></blockquote>
<p>If one of w1, w2 is an array of objects and the other is a
double array:
- If the double is a scalar, it is applied to every object</p>
<blockquote>
<div><p>in the array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with the same size as the object</p></li>
</ul>
<blockquote>
<div><p>array, then each element is applied as a scalar to the
corresponding object in the object array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with larger size than the object</p></li>
</ul>
<blockquote>
<div><p>array, then the array is resolved into a stack of arrays,
where the stack has the same size as the object array, and
the each array in the stack is applied to the corresponding
object in the object array. [Note that for this operation
to be valid, each object must have the same signal array
size.]</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id2">
<h3>Output:<a class="headerlink" href="#id2" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.coth">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">coth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.coth" title="Permalink to this definition"></a></dt>
<dd><p>Implements coth(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = coth(w1)</p>
</div></blockquote>
<section id="id3">
<h3>Input:<a class="headerlink" href="#id3" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id4">
<h3>Output:<a class="headerlink" href="#id4" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.asin">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">asin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.asin" title="Permalink to this definition"></a></dt>
<dd><p>Implements asin(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = asin(w1)</p>
</div></blockquote>
<section id="id5">
<h3>Input:<a class="headerlink" href="#id5" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id6">
<h3>Output:<a class="headerlink" href="#id6" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.atan">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">atan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.atan" title="Permalink to this definition"></a></dt>
<dd><p>Implements atan(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = atan(w1)</p>
</div></blockquote>
<section id="id7">
<h3>Input:<a class="headerlink" href="#id7" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id8">
<h3>Output:<a class="headerlink" href="#id8" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.sqw_eval">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">sqw_eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">sqwfunc</span></em>, <em class="sig-param"><span class="pre">pars</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.sqw_eval" title="Permalink to this definition"></a></dt>
<dd><p>Calculate sqw for a model scattering function</p>
<blockquote>
<div><blockquote>
<div><p>&gt;&gt; wout = sqw_eval(win, sqwfunc, p)
&gt;&gt; wout = sqw_eval(___, ‘-all’)
&gt;&gt; wout = sqw_eval(___, ‘all’, true)
&gt;&gt; wout = sqw_eval(___, ‘-average’)
&gt;&gt; wout = sqw_eval(___, ‘average’, true)
&gt;&gt; sqw_eval(___, ‘outfile’, outfile)
&gt;&gt; wout = sqw_eval(___, ‘outfile’, outfile)
&gt;&gt; sqw_eval(__, ‘outfile’, outfile, ‘filebacked’, true)
&gt;&gt; wout = sqw_eval(__, ‘filebacked’, true)</p>
</div></blockquote>
<blockquote>
<div><dl>
<dt>win        Dataset (or array of datasets) that provides the axes and points</dt><dd><p>for the calculation</p>
</dd>
<dt>sqwfunc     Handle to function that calculates S(Q, w)</dt><dd><dl>
<dt>Most commonly used form is:</dt><dd><blockquote>
<div><p>weight = sqwfunc (qh, qk, ql, en, p)</p>
</div></blockquote>
<dl>
<dt>where</dt><dd><p>qh,qk,ql,en Arrays containing the coordinates of a set of points
p           Vector of parameters needed by dispersion function</p>
<blockquote>
<div><p>e.g. [A, js, gam] as intensity, exchange, lifetime</p>
</div></blockquote>
<p>weight      Array containing calculated spectral weight</p>
</dd>
</dl>
</dd>
<dt>More general form is:</dt><dd><blockquote>
<div><p>weight = sqwfunc (qh, qk, ql, en, p, c1, c2, ..)</p>
</div></blockquote>
<dl class="simple">
<dt>where</dt><dd><dl class="simple">
<dt>p           Typically a vector of parameters that we might want</dt><dd><p>to fit in a least-squares algorithm</p>
</dd>
<dt>c1, c2, …   Other constant parameters e.g. file name for look-up</dt><dd><p>table</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>pars       Arguments needed by the function. Most commonly, a vector of parameter</dt><dd><p>values e.g. [A, js, gam] as intensity, exchange, lifetime. If a more general
set of parameters is required by the function, then
package these into a cell array and pass that as pars. In the example
above then pars = {p, c1, c2, …}</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><dl>
<dt>outfile    If present, the outputs will be written to the file of the given</dt><dd><p>name/path.
If numel(win) &gt; 1, outfile must either be omitted or be a cell
array of file paths with equal number of elements as win.</p>
</dd>
<dt>all        If true, requests that the calculated sqw be returned over</dt><dd><p>the whole of the domain of the input dataset. If false, then
the function will be returned only at those points of the dataset
that contain <a href="#id91"><span class="problematic" id="id92">data_</span></a>.</p>
<blockquote>
<div><p>Applies only to input with no pixel information - it is ignored if</p>
</div></blockquote>
<p>full sqw object.
[default = false]</p>
</dd>
<dt>average    If true, requests that the calculated sqw be computed for the</dt><dd><p>average values of h, k, l of the pixels in a bin, not for each
pixel individually. Reduces cost of expensive calculations.
Applies only to the case of sqw object with pixel information
- it is ignored if dnd type object.
[default = false]</p>
</dd>
<dt>filebacked  If true, the result of the function will be saved to file and</dt><dd><p>the output will be a file path. If no <cite>outfile</cite> is specified,
a unique path within <cite>tempdir()</cite> will be generated.
Default is false.</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Note: all optional string input parameters can be truncated up to minimal</dt><dd><p>difference between them e.g. routine would accept ‘al’ and
‘av’, ‘ave’, ‘aver’ etc….</p>
</dd>
</dl>
<blockquote>
<div><dl class="simple">
<dt>wout        If <cite>filebacked</cite> is false, an sqw object or array of sqw objects.</dt><dd><p>If <cite>filebacked</cite> is true, a file path or cell array of file paths.
Output argument must be specified if <cite>outfile</cite> not given.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
</dd></dl>

<hr class="docutils" />
<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.minus">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">minus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em>, <em class="sig-param"><span class="pre">w2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.minus" title="Permalink to this definition"></a></dt>
<dd><p>Implements w1 - w2 for objects</p>
<blockquote>
<div><p>&gt;&gt; w = w1 - w2</p>
</div></blockquote>
<section id="id9">
<h3>Input:<a class="headerlink" href="#id9" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl>
<dt>w1, w2      Objects on which the binary operation is to be performed.</dt><dd><p>One of these can be a Matlab double (i.e. double precision)
array, in which case the variance array is taken to be zero.</p>
<p>If w1, w2 are scalar objects with the same signal array sizes:
- The operation is performed element-by-element.</p>
<p>If one of w1 or w2 is a double array (and the other is a
scalar object):
- If a scalar, apply to each element of the object signal.
- If it is an array of the same size as the object signal</p>
<blockquote>
<div><p>array, apply the operation element by element.</p>
</div></blockquote>
<p>If one or both of w1 and w2 are arrays of objects:
- If objects have same array sizes, the binary operation is</p>
<blockquote>
<div><p>applied object element-by-object element.</p>
</div></blockquote>
<ul class="simple">
<li><p>If one of the objects is scalar (i.e. only one object),</p></li>
</ul>
<blockquote>
<div><p>then it is applied by the binary operation to each object
in the other array.</p>
</div></blockquote>
<p>If one of w1, w2 is an array of objects and the other is a
double array:
- If the double is a scalar, it is applied to every object</p>
<blockquote>
<div><p>in the array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with the same size as the object</p></li>
</ul>
<blockquote>
<div><p>array, then each element is applied as a scalar to the
corresponding object in the object array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with larger size than the object</p></li>
</ul>
<blockquote>
<div><p>array, then the array is resolved into a stack of arrays,
where the stack has the same size as the object array, and
the each array in the stack is applied to the corresponding
object in the object array. [Note that for this operation
to be valid, each object must have the same signal array
size.]</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id10">
<h3>Output:<a class="headerlink" href="#id10" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.asech">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">asech</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.asech" title="Permalink to this definition"></a></dt>
<dd><p>Implements asech(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = asech(w1)</p>
</div></blockquote>
<section id="id11">
<h3>Input:<a class="headerlink" href="#id11" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id12">
<h3>Output:<a class="headerlink" href="#id12" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.atanh">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">atanh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.atanh" title="Permalink to this definition"></a></dt>
<dd><p>Implements atanh(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = atanh(w1)</p>
</div></blockquote>
<section id="id13">
<h3>Input:<a class="headerlink" href="#id13" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id14">
<h3>Output:<a class="headerlink" href="#id14" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.tan">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">tan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.tan" title="Permalink to this definition"></a></dt>
<dd><p>Implements tan(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = tan(w1)</p>
</div></blockquote>
<section id="id15">
<h3>Input:<a class="headerlink" href="#id15" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id16">
<h3>Output:<a class="headerlink" href="#id16" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.asinh">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">asinh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.asinh" title="Permalink to this definition"></a></dt>
<dd><p>Implements asinh(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = asinh(w1)</p>
</div></blockquote>
<section id="id17">
<h3>Input:<a class="headerlink" href="#id17" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id18">
<h3>Output:<a class="headerlink" href="#id18" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.sinh">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">sinh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.sinh" title="Permalink to this definition"></a></dt>
<dd><p>Implements sinh(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = sinh(w1)</p>
</div></blockquote>
<section id="id19">
<h3>Input:<a class="headerlink" href="#id19" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id20">
<h3>Output:<a class="headerlink" href="#id20" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.multifit_sqw_sqw">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">multifit_sqw_sqw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.multifit_sqw_sqw" title="Permalink to this definition"></a></dt>
<dd><p>Simultaneously fit function(s) of S(Q,w)to one or more sqw objects</p>
<blockquote>
<div><blockquote>
<div><p>&gt;&gt; myobj = multifit_sqw_sqw (w1, w2, …)      % w1, w2 objects or arrays of objects</p>
</div></blockquote>
<p>This creates a fitting object of class mfclass_Horace_sqw_sqw with the provided data,
which can then be manipulated to add further data, set the fitting
functions, initial parameter values etc. and fit or simulate the data.
For details about how to do this  &lt;a href=”matlab:help(‘mfclass_Horace_sqw_sqw’);”&gt;Click here&lt;/a&gt;</p>
<p>For example:</p>
<blockquote>
<div><dl class="simple">
<dt>&gt;&gt; myobj = multifit_sqw_sqw (w1, w2, …); % set the data</dt><dd><p>:</p>
</dd>
</dl>
<p>&gt;&gt; myobj = myobj.set_fun (&#64;function_name, pars);  % set forgraound function(s)
&gt;&gt; myobj = myobj.set_bfun (&#64;function_name, pars); % set background function(s)</p>
<blockquote>
<div><p>:</p>
</div></blockquote>
<p>&gt;&gt; myobj = myobj.set_free (pfree);      % set which parameters are floating
&gt;&gt; myobj = myobj.set_bfree (bpfree);    % set which parameters are floating
&gt;&gt; [wfit,fitpars] = myobj.fit;          % perform fit</p>
</div></blockquote>
<p>This method fits function(s) of S(Q,w) as both the foreground and
the background function(s). For the format of the fit functions:
&lt;a href=”matlab:edit(‘example_sqw_spin_waves’);”&gt;Damped spin waves&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_sqw_flat_mode’);”&gt;Dispersionless excitations&lt;/a&gt;</p>
<p>See also multifit multifit_sqw</p>
</div></blockquote>
<blockquote>
<div><p>method_name = ‘multifit_sqw_sqw’
mfclass_name = ‘mfclass_Horace_sqw_sqw’
function_tag = ‘of S(Q,w) ‘</p>
<p>multifit_doc = fullfile(fileparts(which(‘multifit’)),’_docify’)
sqw_doc = fullfile(fileparts(which(‘mfclass_Horace’)),’_docify’)</p>
<p>doc_multifit_header = fullfile(multifit_doc,’doc_multifit_header.m’)
doc_fit_functions = fullfile(sqw_doc,’doc_multifit_sqw_sqw_fit_functions_for_sqw.m’)</p>
</div></blockquote>
<blockquote>
<div><blockquote>
<div><p>&lt;#file:&gt;  &lt;doc_fit_functions&gt;</p>
</div></blockquote>
<p>See also multifit multifit_sqw</p>
<p>&lt;#doc_end:&gt;</p>
</div></blockquote>
</dd></dl>

<hr class="docutils" />
<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.log">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.log" title="Permalink to this definition"></a></dt>
<dd><p>Implements log(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = log(w1)</p>
</div></blockquote>
<section id="id21">
<h3>Input:<a class="headerlink" href="#id21" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id22">
<h3>Output:<a class="headerlink" href="#id22" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.mtimes">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">mtimes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em>, <em class="sig-param"><span class="pre">w2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.mtimes" title="Permalink to this definition"></a></dt>
<dd><p>Implements w1 * w2 for objects</p>
<blockquote>
<div><p>&gt;&gt; w = w1 * w2</p>
</div></blockquote>
<section id="id23">
<h3>Input:<a class="headerlink" href="#id23" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl>
<dt>w1, w2      Objects on which the binary operation is to be performed.</dt><dd><p>One of these can be a Matlab double (i.e. double precision)
array, in which case the variance array is taken to be zero.</p>
<p>If w1, w2 are scalar objects with the same signal array sizes:
- The operation is performed element-by-element.</p>
<p>If one of w1 or w2 is a double array (and the other is a
scalar object):
- If a scalar, apply to each element of the object signal.
- If it is an array of the same size as the object signal</p>
<blockquote>
<div><p>array, apply the operation element by element.</p>
</div></blockquote>
<p>If one or both of w1 and w2 are arrays of objects:
- If objects have same array sizes, the binary operation is</p>
<blockquote>
<div><p>applied object element-by-object element.</p>
</div></blockquote>
<ul class="simple">
<li><p>If one of the objects is scalar (i.e. only one object),</p></li>
</ul>
<blockquote>
<div><p>then it is applied by the binary operation to each object
in the other array.</p>
</div></blockquote>
<p>If one of w1, w2 is an array of objects and the other is a
double array:
- If the double is a scalar, it is applied to every object</p>
<blockquote>
<div><p>in the array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with the same size as the object</p></li>
</ul>
<blockquote>
<div><p>array, then each element is applied as a scalar to the
corresponding object in the object array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with larger size than the object</p></li>
</ul>
<blockquote>
<div><p>array, then the array is resolved into a stack of arrays,
where the stack has the same size as the object array, and
the each array in the stack is applied to the corresponding
object in the object array. [Note that for this operation
to be valid, each object must have the same signal array
size.]</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id24">
<h3>Output:<a class="headerlink" href="#id24" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.SQWDnDBase">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">SQWDnDBase</span></span><a class="headerlink" href="#sqw.@SQWDnDBase.SQWDnDBase" title="Permalink to this definition"></a></dt>
<dd><p>SQWDnDBase Abstract SQW/DnD object base class</p>
<p>Abstract class defining common API and attributes of the SQW and
DnD objects</p>
<div class="members docutils container">
<dl>
<dt>Property Summary</dt><dd><dl class="mat attribute">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.SQWDnDBase.border_size">
<span class="sig-name descname"><span class="pre">border_size</span></span><a class="headerlink" href="#sqw.@SQWDnDBase.SQWDnDBase.border_size" title="Permalink to this definition"></a></dt>
<dd><p>the size of the border, used in gen_sqw. The img_db_range in gen_sqw
exceeds real pix_range (or input pix_range) by this value.</p>
</dd></dl>

</dd>
</dl>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.equal_to_tol">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">equal_to_tol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em>, <em class="sig-param"><span class="pre">w2</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.equal_to_tol" title="Permalink to this definition"></a></dt>
<dd><p>Check if two sqw objects are equal to a given tolerance</p>
<blockquote>
<div><p>&gt;&gt; ok = equal_to_tol (a, b)
&gt;&gt; ok = equal_to_tol (a, b, tol)
&gt;&gt; ok = equal_to_tol (…, keyword1, val1, keyword2, val2,…)
&gt;&gt; [ok, mess] = equal_to_tol (…)</p>
</div></blockquote>
<dl class="simple">
<dt>Class specific version of the generic equal_to_tol that by default</dt><dd><ol class="arabic simple">
<li><p>assumes NaN are equivalent (see option ‘nan_equal’), and</p></li>
<li><p>ignores the order of pixels within a bin as the order is irrelevant
(change the default with option ‘reorder’)</p></li>
</ol>
</dd>
</dl>
<p>In addition, it is possible to check the contents of just a random
fraction of non-empty bins (see option ‘fraction’) in order to speed up
the comparison of large objects.</p>
<section id="id25">
<h3>Input:<a class="headerlink" href="#id25" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w1,w2   Test objects (scalar objects, or arrays of objects with same sizes)</p>
<dl>
<dt>tol     Tolerance criterion for numeric arrays (Default: [0,0] i.e. equality)</dt><dd><dl class="simple">
<dt>It has the form: [abstol, reltol] where</dt><dd><p>abstol     absolute tolerance (&gt;=0; if =0 equality required)
reltol     relative tolerance (&gt;=0; if =0 equality required)</p>
</dd>
</dl>
<p>If either criterion is satified then equality within tolerance
is accepted.</p>
<blockquote>
<div><dl class="simple">
<dt>Examples:</dt><dd><p>[1e-4, 1e-6]    absolute 1e-4 or relative 1e-6 required
[1e-4, 0]       absolute 1e-4 required
[0, 1e-6]       relative 1e-6 required
[0, 0]          equality required
0               equivalent to [0,0]</p>
</dd>
</dl>
</div></blockquote>
<p>For backwards compatibility, a scalar tolerance can be given
where the sign determines absolute or relative tolerance</p>
<blockquote>
<div><blockquote>
<div><p>+ve : absolute tolerance  abserr = abs(a-b)
-ve : relative tolerance  relerr = abs(a-b)/max(abs(a),abs(b))</p>
</div></blockquote>
<dl class="simple">
<dt>Examples:</dt><dd><p>1e-4            absolute tolerance, equivalent to [1e-4, 0]
-1e-6           relative tolerance, equivalent to [0, 1e-6]</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>[To apply an absolute as well as a relative tolerance with a</dt><dd><p>scalar negative value, set the value of the legacy keyword</p>
</dd>
</dl>
<p>‘min_denominator’ (see below)]</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>Valid keywords are:</dt><dd><p>‘nan_equal’      Treat NaNs as equal (true or false; default=true)</p>
<dl>
<dt>‘ignore_str’     Ignore the length and content of strings or cell arrays</dt><dd><p>of strings (true or false; default=false)</p>
</dd>
<dt>‘reorder’        Ignore the order of pixels within each bin</dt><dd><dl class="simple">
<dt>(true or false; default=true)</dt><dd><p>Only applies if sqw-type object</p>
</dd>
</dl>
</dd>
<dt>‘fraction’       Compare pixels in only a fraction of the non-empty bins</dt><dd><dl class="simple">
<dt>(0&lt;= fracton &lt;= 1; default=1 i.e. test all bins)</dt><dd><p>Only applies if sqw-type object</p>
</dd>
</dl>
</dd>
<dt>‘-ignore_date’   (provided without additional values, so its presence in</dt><dd><blockquote>
<div><blockquote>
<div><p>the sequence of keywords means true). If provided,
ignore file creation date stored in main header.</p>
</div></blockquote>
<p>The reorder and fraction options are available because the order of the</p>
</div></blockquote>
<p>pixels within the pix array for a given bin is unimportant. Reordering
takes time, however, so the option to test on a few bins is given.</p>
</dd>
</dl>
</dd>
</dl>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.log10">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">log10</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.log10" title="Permalink to this definition"></a></dt>
<dd><p>Implements log10(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = log10(w1)</p>
</div></blockquote>
<section id="id26">
<h3>Input:<a class="headerlink" href="#id26" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id27">
<h3>Output:<a class="headerlink" href="#id27" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.plus">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">plus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em>, <em class="sig-param"><span class="pre">w2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.plus" title="Permalink to this definition"></a></dt>
<dd><p>Implements w1 + w2 for objects</p>
<blockquote>
<div><p>&gt;&gt; w = w1 + w2</p>
</div></blockquote>
<section id="id28">
<h3>Input:<a class="headerlink" href="#id28" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl>
<dt>w1, w2      Objects on which the binary operation is to be performed.</dt><dd><p>One of these can be a Matlab double (i.e. double precision)
array, in which case the variance array is taken to be zero.</p>
<p>If w1, w2 are scalar objects with the same signal array sizes:
- The operation is performed element-by-element.</p>
<p>If one of w1 or w2 is a double array (and the other is a
scalar object):
- If a scalar, apply to each element of the object signal.
- If it is an array of the same size as the object signal</p>
<blockquote>
<div><p>array, apply the operation element by element.</p>
</div></blockquote>
<p>If one or both of w1 and w2 are arrays of objects:
- If objects have same array sizes, the binary operation is</p>
<blockquote>
<div><p>applied object element-by-object element.</p>
</div></blockquote>
<ul class="simple">
<li><p>If one of the objects is scalar (i.e. only one object),</p></li>
</ul>
<blockquote>
<div><p>then it is applied by the binary operation to each object
in the other array.</p>
</div></blockquote>
<p>If one of w1, w2 is an array of objects and the other is a
double array:
- If the double is a scalar, it is applied to every object</p>
<blockquote>
<div><p>in the array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with the same size as the object</p></li>
</ul>
<blockquote>
<div><p>array, then each element is applied as a scalar to the
corresponding object in the object array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with larger size than the object</p></li>
</ul>
<blockquote>
<div><p>array, then the array is resolved into a stack of arrays,
where the stack has the same size as the object array, and
the each array in the stack is applied to the corresponding
object in the object array. [Note that for this operation
to be valid, each object must have the same signal array
size.]</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id29">
<h3>Output:<a class="headerlink" href="#id29" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.exp">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.exp" title="Permalink to this definition"></a></dt>
<dd><p>Implements exp(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = exp(w1)</p>
</div></blockquote>
<section id="id30">
<h3>Input:<a class="headerlink" href="#id30" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id31">
<h3>Output:<a class="headerlink" href="#id31" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.acos">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">acos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.acos" title="Permalink to this definition"></a></dt>
<dd><p>Implements acos(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = acos(w1)</p>
</div></blockquote>
<section id="id32">
<h3>Input:<a class="headerlink" href="#id32" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id33">
<h3>Output:<a class="headerlink" href="#id33" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.tanh">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">tanh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.tanh" title="Permalink to this definition"></a></dt>
<dd><p>Implements tanh(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = tanh(w1)</p>
</div></blockquote>
<section id="id34">
<h3>Input:<a class="headerlink" href="#id34" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id35">
<h3>Output:<a class="headerlink" href="#id35" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.save">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.save" title="Permalink to this definition"></a></dt>
<dd><p>Save a sqw object or array of sqw objects to file</p>
<blockquote>
<div><p>&gt;&gt; save (w)              % prompt for file
&gt;&gt; save (w, file)        % give file
&gt;&gt; save (w, file,loader) % save file using specific data loader</p>
<blockquote>
<div><p>(-update option, is provided, will be
ignored)</p>
</div></blockquote>
<dl class="simple">
<dt>&gt;&gt; save (w, file,[‘-parallel’<a href="#id36"><span class="problematic" id="id37">|</span></a>JobDispatcher])</dt><dd><p>combine file using parallel algorithm.
Useful and would works only if (when) pix
value of sqw object data is set up to the
instance of pix_combine_info class,
containing information on the partial
tmp files, written by filebased gen_sqw or
cut algorithm</p>
</dd>
<dt>&gt;&gt; save (w, file,’-update’) % if the target file exist, update it to</dt><dd><p>latest format if this is possible. If
update is possible, pixels in file will not be
overwritten.</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>Input:</dt><dd><p>w       sqw object
file    [optional] File for output. if none given, then prompted for a file</p>
<p>Note that if w is an array of sqw objects then file must be a cell
array of filenames of the same size.</p>
</dd>
</dl>
<p>Optional output:
cl – running instance of parallel cluster, used to combine multiple tmp</p>
<blockquote>
<div><blockquote>
<div><p>files together if pix field of sqw object contains pix_combine_into
and -parallel option or parallel cluster itself are provided as
inpout. Empty in any other case</p>
</div></blockquote>
<p>TODO: currently empty. May re-enable when parallel saving is
implemented properly</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.acsch">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">acsch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.acsch" title="Permalink to this definition"></a></dt>
<dd><p>Implements acsch(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = acsch(w1)</p>
</div></blockquote>
<section id="id38">
<h3>Input:<a class="headerlink" href="#id38" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id39">
<h3>Output:<a class="headerlink" href="#id39" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.uminus">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">uminus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.uminus" title="Permalink to this definition"></a></dt>
<dd><p>Implements uminus(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = uminus(w1)</p>
</div></blockquote>
<section id="id40">
<h3>Input:<a class="headerlink" href="#id40" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id41">
<h3>Output:<a class="headerlink" href="#id41" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.acosh">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">acosh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.acosh" title="Permalink to this definition"></a></dt>
<dd><p>Implements acosh(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = acosh(w1)</p>
</div></blockquote>
<section id="id42">
<h3>Input:<a class="headerlink" href="#id42" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id43">
<h3>Output:<a class="headerlink" href="#id43" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.acot">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">acot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.acot" title="Permalink to this definition"></a></dt>
<dd><p>Implements acot(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = acot(w1)</p>
</div></blockquote>
<section id="id44">
<h3>Input:<a class="headerlink" href="#id44" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id45">
<h3>Output:<a class="headerlink" href="#id45" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.cos">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">cos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.cos" title="Permalink to this definition"></a></dt>
<dd><p>Implements cos(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = cos(w1)</p>
</div></blockquote>
<section id="id46">
<h3>Input:<a class="headerlink" href="#id46" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id47">
<h3>Output:<a class="headerlink" href="#id47" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.acoth">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">acoth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.acoth" title="Permalink to this definition"></a></dt>
<dd><p>Implements acoth(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = acoth(w1)</p>
</div></blockquote>
<section id="id48">
<h3>Input:<a class="headerlink" href="#id48" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id49">
<h3>Output:<a class="headerlink" href="#id49" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.uplus">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">uplus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.uplus" title="Permalink to this definition"></a></dt>
<dd><p>Implements uplus(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = uplus(w1)</p>
</div></blockquote>
<section id="id50">
<h3>Input:<a class="headerlink" href="#id50" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id51">
<h3>Output:<a class="headerlink" href="#id51" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.cot">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">cot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.cot" title="Permalink to this definition"></a></dt>
<dd><p>Implements cot(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = cot(w1)</p>
</div></blockquote>
<section id="id52">
<h3>Input:<a class="headerlink" href="#id52" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id53">
<h3>Output:<a class="headerlink" href="#id53" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.binary_op_manager">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">binary_op_manager</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em>, <em class="sig-param"><span class="pre">w2</span></em>, <em class="sig-param"><span class="pre">binary_op</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.binary_op_manager" title="Permalink to this definition"></a></dt>
<dd><p>Implements a binary operation for objects with a signal and a variance array.</p>
<blockquote>
<div><p>&gt;&gt; w = binary_op_manager(w1, w2, binary_op)</p>
</div></blockquote>
<p>All binary operations on Matlab double arrays are permitted
(+, -, <a href="#id54"><span class="problematic" id="id55">*</span></a>, /, ) and are applied element by element to the signal and
variance arrays.</p>
<section id="id56">
<h3>Input:<a class="headerlink" href="#id56" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl>
<dt>w1, w2      Objects on which the binary operation is to be performed.</dt><dd><p>One of these can be a Matlab double (i.e. double precision)
array, in which case the variance array is taken to be zero.</p>
<p>If w1, w2 are scalar objects with the same signal array sizes:
- The operation is performed element-by-element.</p>
<p>If one of w1 or w2 is a double array (and the other is a
scalar object):
- If a scalar, apply to each element of the object signal.
- If it is an array of the same size as the object signal</p>
<blockquote>
<div><p>array, apply the operation element by element.</p>
</div></blockquote>
<p>If one or both of w1 and w2 are arrays of objects:
- If objects have same array sizes, the binary operation is</p>
<blockquote>
<div><p>applied object element-by-object element.</p>
</div></blockquote>
<ul class="simple">
<li><p>If one of the objects is scalar (i.e. only one object),</p></li>
</ul>
<blockquote>
<div><p>then it is applied by the binary operation to each object
in the other array.</p>
</div></blockquote>
<p>If one of w1, w2 is an array of objects and the other is a
double array:
- If the double is a scalar, it is applied to every object</p>
<blockquote>
<div><p>in the array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with the same size as the object</p></li>
</ul>
<blockquote>
<div><p>array, then each element is applied as a scalar to the
corresponding object in the object array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with larger size than the object</p></li>
</ul>
<blockquote>
<div><p>array, then the array is resolved into a stack of arrays,
where the stack has the same size as the object array, and
the each array in the stack is applied to the corresponding
object in the object array. [Note that for this operation
to be valid, each object must have the same signal array
size.]</p>
</div></blockquote>
</dd>
<dt>binary_op   Function handle to a binary operation. All binary operations</dt><dd><p>on Matlab double or single arrays are permitted (+, -, <a href="#id57"><span class="problematic" id="id58">*</span></a>,
/, ).</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id59">
<h3>Output:<a class="headerlink" href="#id59" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
<p>NOTES:
This is a generic method - works for any class (including sigvar)
so long as the methods below are defined on that class.</p>
<p>Requires that objects have the following methods to find the size of the
public signal and variance arrays, create a sigvar object from those
arrays, and set them from another sigvar object.</p>
<blockquote>
<div><dl class="simple">
<dt>&gt;&gt; sz = sigvar_size(obj)    % Returns size of public signal and variance</dt><dd><p>% arrays</p>
</dd>
<dt>&gt;&gt; w = sigvar(obj)          % Create a sigvar object from the public</dt><dd><p>% signal and variance arrays</p>
</dd>
<dt>&gt;&gt; obj = sigvar_set(obj,w)  % Set signal and variance in an object from</dt><dd><p>% those in a sigvar object</p>
</dd>
</dl>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.mpower">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">mpower</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em>, <em class="sig-param"><span class="pre">w2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.mpower" title="Permalink to this definition"></a></dt>
<dd><p>Implements w1 ^ w2 for objects</p>
<blockquote>
<div><p>&gt;&gt; w = w1 ^ w2</p>
</div></blockquote>
<section id="id60">
<h3>Input:<a class="headerlink" href="#id60" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl>
<dt>w1, w2      Objects on which the binary operation is to be performed.</dt><dd><p>One of these can be a Matlab double (i.e. double precision)
array, in which case the variance array is taken to be zero.</p>
<p>If w1, w2 are scalar objects with the same signal array sizes:
- The operation is performed element-by-element.</p>
<p>If one of w1 or w2 is a double array (and the other is a
scalar object):
- If a scalar, apply to each element of the object signal.
- If it is an array of the same size as the object signal</p>
<blockquote>
<div><p>array, apply the operation element by element.</p>
</div></blockquote>
<p>If one or both of w1 and w2 are arrays of objects:
- If objects have same array sizes, the binary operation is</p>
<blockquote>
<div><p>applied object element-by-object element.</p>
</div></blockquote>
<ul class="simple">
<li><p>If one of the objects is scalar (i.e. only one object),</p></li>
</ul>
<blockquote>
<div><p>then it is applied by the binary operation to each object
in the other array.</p>
</div></blockquote>
<p>If one of w1, w2 is an array of objects and the other is a
double array:
- If the double is a scalar, it is applied to every object</p>
<blockquote>
<div><p>in the array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with the same size as the object</p></li>
</ul>
<blockquote>
<div><p>array, then each element is applied as a scalar to the
corresponding object in the object array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with larger size than the object</p></li>
</ul>
<blockquote>
<div><p>array, then the array is resolved into a stack of arrays,
where the stack has the same size as the object array, and
the each array in the stack is applied to the corresponding
object in the object array. [Note that for this operation
to be valid, each object must have the same signal array
size.]</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id61">
<h3>Output:<a class="headerlink" href="#id61" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.sin">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">sin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.sin" title="Permalink to this definition"></a></dt>
<dd><p>Implements sin(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = sin(w1)</p>
</div></blockquote>
<section id="id62">
<h3>Input:<a class="headerlink" href="#id62" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id63">
<h3>Output:<a class="headerlink" href="#id63" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.csc">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">csc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.csc" title="Permalink to this definition"></a></dt>
<dd><p>Implements csc(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = csc(w1)</p>
</div></blockquote>
<section id="id64">
<h3>Input:<a class="headerlink" href="#id64" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id65">
<h3>Output:<a class="headerlink" href="#id65" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.sqrt">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">sqrt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.sqrt" title="Permalink to this definition"></a></dt>
<dd><p>Implements sqrt(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = sqrt(w1)</p>
</div></blockquote>
<section id="id66">
<h3>Input:<a class="headerlink" href="#id66" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id67">
<h3>Output:<a class="headerlink" href="#id67" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.mask_points">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">mask_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.mask_points" title="Permalink to this definition"></a></dt>
<dd><p>TODO: Does not look like this function should be here</p>
<p>Determine the points to keep on the basis of ranges and mask array.</p>
<blockquote>
<div><p>&gt;&gt; sel = mask_points (win, ‘keep’, xkeep, ‘remove’, xremove, ‘mask’, mask)</p>
</div></blockquote>
<p>or any selection (in any order) of the keyword-argument pairs e.g.</p>
<blockquote>
<div><p>&gt;&gt; sel = mask_points (win, ‘mask’, mask, ‘remove’, xremove)</p>
</div></blockquote>
<section id="id68">
<h3>Input:<a class="headerlink" href="#id68" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>win     Input sqw object</p>
<dl>
<dt>xkeep   Ranges of display axes to retain for fitting. A range is specified by an array</dt><dd><p>of numbers which define a hypercube.
For example in case of two dimensions:</p>
<blockquote>
<div><p>[xlo, xhi, ylo, yhi]</p>
</div></blockquote>
<dl>
<dt>or in the case of n-dimensions:</dt><dd><blockquote>
<div><p>[x1_lo, x1_hi, x2_lo, x2_hi,…, xn_lo, xn_hi]</p>
</div></blockquote>
<dl class="simple">
<dt>e.g. 1D: [50,70]</dt><dd><p>2D: [1,2,130,160]</p>
</dd>
</dl>
</dd>
<dt>More than one range can be defined in rows,</dt><dd><blockquote>
<div><p>[Range_1; Range_2; Range_3;…; Range_m]</p>
</div></blockquote>
<p>where each of the ranges are given in the format above.</p>
</dd>
</dl>
</dd>
</dl>
<p>xremove Ranges of display axes to remove from fitting.</p>
<dl>
<dt>mask    Mask array of same number of elements as data array: 1 to keep, 0 to remove</dt><dd><blockquote>
<div><p>Note: mask will be applied to the stored data array</p>
</div></blockquote>
<p>according as the projection axes, not the display axes.
Thus permuting the display axes does not alter the
effect of masking the data. The mask array works
consistently with the input required by the mask method.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id69">
<h3>Output:<a class="headerlink" href="#id69" title="Permalink to this heading"></a></h3>
<blockquote>
<div><blockquote>
<div><p>sel     Mask array of same shape as <a href="#id93"><span class="problematic" id="id94">data_</span></a>. true for bins to keep, false to discard.</p>
</div></blockquote>
<p>Advanced use: in addition the following two arguments, if present, suppress failure or the
display of informational messges. Instead, the messages are returned to be used as desired.</p>
<blockquote>
<div><p>ok      =true if worked, =false if error</p>
<p>mess    messages: if ok=true then informational or warning, if ok=false then the error message</p>
</div></blockquote>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.cosh">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">cosh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.cosh" title="Permalink to this definition"></a></dt>
<dd><p>Implements cosh(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = cosh(w1)</p>
</div></blockquote>
<section id="id70">
<h3>Input:<a class="headerlink" href="#id70" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id71">
<h3>Output:<a class="headerlink" href="#id71" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.multifit_func">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">multifit_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.multifit_func" title="Permalink to this definition"></a></dt>
<dd><p>Simultaneously fit function(s) to one or more sqw objects</p>
<blockquote>
<div><p>&gt;&gt; myobj = multifit_func (w1, w2, …)      % w1, w2 objects or arrays of objects</p>
</div></blockquote>
<p>This creates a fitting object of class mfclass_Horace with the provided data,
which can then be manipulated to add further data, set the fitting
functions, initial parameter values etc. and fit or simulate the data.
For details about how to do this  &lt;a href=”matlab:help(‘mfclass_Horace’);”&gt;Click here&lt;/a&gt;</p>
<p>For example:</p>
<blockquote>
<div><dl class="simple">
<dt>&gt;&gt; myobj = multifit_func (w1, w2, …); % set the data</dt><dd><p>:</p>
</dd>
</dl>
<p>&gt;&gt; myobj = myobj.set_fun (&#64;function_name, pars);  % set forgraound function(s)
&gt;&gt; myobj = myobj.set_bfun (&#64;function_name, pars); % set background function(s)</p>
<blockquote>
<div><p>:</p>
</div></blockquote>
<p>&gt;&gt; myobj = myobj.set_free (pfree);      % set which parameters are floating
&gt;&gt; myobj = myobj.set_bfree (bpfree);    % set which parameters are floating
&gt;&gt; [wfit,fitpars] = myobj.fit;          % perform fit</p>
</div></blockquote>
<p>This method fits function(s) of the plot axes for both the foreground and
the background function(s). The format of the fit functions depends on
the number of plot axes for each sqw object. For examples see:
&lt;a href=”matlab:edit(‘example_1d_function’);”&gt;example_1d_function&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_2d_function’);”&gt;example_2d_function&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_3d_function’);”&gt;example_3d_function&lt;/a&gt;</p>
<p>See also multifit_sqw multifit_sqw_sqw</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.asec">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">asec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.asec" title="Permalink to this definition"></a></dt>
<dd><p>Implements asec(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = asec(w1)</p>
</div></blockquote>
<section id="id72">
<h3>Input:<a class="headerlink" href="#id72" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id73">
<h3>Output:<a class="headerlink" href="#id73" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.sqw_eval_nopix">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">sqw_eval_nopix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">sqwfunc</span></em>, <em class="sig-param"><span class="pre">all_bins</span></em>, <em class="sig-param"><span class="pre">pars</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.sqw_eval_nopix" title="Permalink to this definition"></a></dt>
<dd><p>SQW_EVAL_NOPIX</p>
<blockquote>
<div><p>Helper function for sqw eval executed on a pixel-less object (i.e. DnD or SQW with no pixels
Called by <cite>sqw_eval_</cite> defined in sqw/DnDBase</p>
<blockquote>
<div><dl class="simple">
<dt>obj        Dataset (or array of datasets) that provides the axes and points</dt><dd><p>for the calculation</p>
</dd>
</dl>
<p>sqwfunc     Handle to function that calculates S(Q,w)
all_bins    Boolean flag wither to apply function to all bins or only those contaiing data
pars       Arguments needed by the function.</p>
</div></blockquote>
</div></blockquote>
</dd></dl>

<hr class="docutils" />
<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.sec">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">sec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.sec" title="Permalink to this definition"></a></dt>
<dd><p>Implements sec(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = sec(w1)</p>
</div></blockquote>
<section id="id74">
<h3>Input:<a class="headerlink" href="#id74" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id75">
<h3>Output:<a class="headerlink" href="#id75" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.csch">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">csch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.csch" title="Permalink to this definition"></a></dt>
<dd><p>Implements csch(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = csch(w1)</p>
</div></blockquote>
<section id="id76">
<h3>Input:<a class="headerlink" href="#id76" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id77">
<h3>Output:<a class="headerlink" href="#id77" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.dispersion">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">dispersion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">dispreln</span></em>, <em class="sig-param"><span class="pre">pars</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.dispersion" title="Permalink to this definition"></a></dt>
<dd><p>Calculate dispersion relation for dataset or array of datasets.</p>
<p>New behaviour: Always returns appropriate dnd object. May be modified in
a future.</p>
<p>If the input contains array of sqw objects, the objects need to have the
same number of dimensions (may be relaxed if requested)</p>
<blockquote>
<div><p>&gt;&gt; wdisp = dispersion (win, dispreln, p)            % dispersion only
&gt;&gt; [wdisp,weight] = dispersion (win, dispreln, p)   % dispersion and spectral weight</p>
</div></blockquote>
<p>The output dataset (or array of data sets), wdisp, will retain only the Q axes, and
the signal array(s) will contain the values of energy along the Q axes. If the
dispersion relation returns the spectral weight, this will be placed in the error
array (actually the square of the spectral weight is put in the error array). In the
case when the dispersion has been calculated on a plane in momentum (i.e. wdisp
is IX_datset_2d) then the plot function ps2 (for plot_surface2)</p>
<blockquote>
<div><p>&gt;&gt; ps2(wdisp)</p>
</div></blockquote>
<p>will plot a surface with the z axis as energy and coloured according to the spectral
weight.</p>
<p>The dispersion relation is calculated at the bin centres (that is, the individual pixel
information in a sqw input object is not used).</p>
<p>If the function that calculates dispersion relations produces more than one
branch, then in the case of a single input dataset the output will be an array
of datasets, one for each branch. If the input is an array of datasets, then only
the first dispersion branch will be returned, so there is one output dataset per
input dataset.</p>
<section id="id78">
<h3>Input:<a class="headerlink" href="#id78" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl>
<dt>win         Dataset that provides the axes and points for the calculation</dt><dd><blockquote>
<div><p>If one of the plot axes is energy transfer, then the output dataset</p>
</div></blockquote>
<p>will have dimensionality one less than the input dataset</p>
</dd>
<dt>dispreln    Handle to function that calculates the dispersion relation w(Q)</dt><dd><dl>
<dt>Must have form:</dt><dd><blockquote>
<div><p>[w,s] = dispreln (qh,qk,ql,p)</p>
</div></blockquote>
<dl class="simple">
<dt>where</dt><dd><dl class="simple">
<dt>qh,qk,ql    Arrays containing the coordinates of a set of points</dt><dd><p>in reciprocal lattice units</p>
</dd>
<dt>p           Vector of parameters needed by dispersion function</dt><dd><p>e.g. [A,js,gam] as intensity, exchange, lifetime</p>
</dd>
<dt>w           Array of corresponding energies, or, if more than</dt><dd><p>one dispersion relation, a cell array of arrays.</p>
</dd>
<dt>s           Array of spectral weights, or, if more than</dt><dd><p>one dispersion relation, a cell array of arrays.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>More general form is:</dt><dd><blockquote>
<div><p>[w,s] = dispreln (qh,qk,ql,p,c1,c2,..)</p>
</div></blockquote>
<dl class="simple">
<dt>where</dt><dd><dl class="simple">
<dt>p           Typically a vector of parameters that we might want</dt><dd><p>to fit in a least-squares algorithm</p>
</dd>
<dt>c1,c2,…   Other constant parameters e.g. file name for look-up</dt><dd><p>table.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>p           Arguments needed by the function. Most commonly, a vector of parameter</dt><dd><p>values e.g. [A,js,gam] as intensity, exchange, lifetime. If a more general
set of parameters is required by the function, then
package these into a cell array and pass that as pars. In the example
above then pars = {p, c1, c2, …}</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id79">
<h3>Output:<a class="headerlink" href="#id79" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl>
<dt>wdisp       Output dataset or array of datasets of the same type as the input argument.</dt><dd><blockquote>
<div><p>The output dataset (or array of data sets) will retain only the Q axes, the</p>
</div></blockquote>
<p>the signal array(s) will contain the values of energy along the Q axes, and
the error array will contain the square of the spectral weight.</p>
<blockquote>
<div><p>If the function that calculates dispersion relations produces more than one</p>
</div></blockquote>
<p>branch, then in the case of a single input dataset the output will be an array
of datasets, one for each branch. If the input is an array of datasets, then only
the first dispersion branch will be returned, so there is one output dataset per
input dataset.</p>
</dd>
<dt>weight      Mirror output: the signal is the spectral weight, and the error array</dt><dd><p>contains the square of the frequency.</p>
</dd>
<dt>e.g.        If win is a 2D dataset with Q and E axes, then wdisp is a 1D dataset</dt><dd><p>with just the Q axis</p>
</dd>
</dl>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.multifit_sqw">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">multifit_sqw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.multifit_sqw" title="Permalink to this definition"></a></dt>
<dd><p>Simultaneously fit function(s) of S(Q,w)to one or more sqw objects</p>
<blockquote>
<div><blockquote>
<div><p>&gt;&gt; myobj = multifit_sqw (w1, w2, …)      % w1, w2 objects or arrays of objects</p>
</div></blockquote>
<p>This creates a fitting object of class mfclass_Horace_sqw with the provided data,
which can then be manipulated to add further data, set the fitting
functions, initial parameter values etc. and fit or simulate the data.
For details about how to do this  &lt;a href=”matlab:help(‘mfclass_Horace_sqw’);”&gt;Click here&lt;/a&gt;</p>
<p>For example:</p>
<blockquote>
<div><dl class="simple">
<dt>&gt;&gt; myobj = multifit_sqw (w1, w2, …); % set the data</dt><dd><p>:</p>
</dd>
</dl>
<p>&gt;&gt; myobj = myobj.set_fun (&#64;function_name, pars);  % set forgraound function(s)
&gt;&gt; myobj = myobj.set_bfun (&#64;function_name, pars); % set background function(s)</p>
<blockquote>
<div><p>:</p>
</div></blockquote>
<p>&gt;&gt; myobj = myobj.set_free (pfree);      % set which parameters are floating
&gt;&gt; myobj = myobj.set_bfree (bpfree);    % set which parameters are floating
&gt;&gt; [wfit,fitpars] = myobj.fit;          % perform fit</p>
</div></blockquote>
<p>This method fits model(s) for S(Q,w) as the foreground function(s), and
function(s) of the plot axes for the background function(s)</p>
<p>For the format of foreground fit functions:
&lt;a href=”matlab:edit(‘example_sqw_spin_waves’);”&gt;Damped spin waves&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_sqw_flat_mode’);”&gt;Dispersionless excitations&lt;/a&gt;</p>
<p>The format of the background fit functions depends on the number of plot
axes for each sqw object. For examples see:
&lt;a href=”matlab:edit(‘example_1d_function’);”&gt;example_1d_function&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_2d_function’);”&gt;example_2d_function&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_3d_function’);”&gt;example_3d_function&lt;/a&gt;</p>
<p>See also multifit multifit_sqw_sqw</p>
</div></blockquote>
<blockquote>
<div><p>method_name = ‘multifit_sqw’
mfclass_name = ‘mfclass_Horace_sqw’
function_tag = ‘of S(Q,w) ‘</p>
<p>multifit_doc = fullfile(fileparts(which(‘multifit’)),’_docify’)
sqw_doc = fullfile(fileparts(which(‘mfclass_Horace’)),’_docify’)</p>
<p>doc_multifit_header = fullfile(multifit_doc,’doc_multifit_header.m’)
doc_fit_functions = fullfile(sqw_doc,’doc_multifit_sqw_fit_functions_for_sqw.m’)</p>
</div></blockquote>
<blockquote>
<div><blockquote>
<div><p>&lt;#file:&gt;  &lt;doc_fit_functions&gt;</p>
</div></blockquote>
<p>See also multifit multifit_sqw_sqw</p>
<p>&lt;#doc_end:&gt;</p>
</div></blockquote>
</dd></dl>

<hr class="docutils" />
<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.sech">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">sech</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.sech" title="Permalink to this definition"></a></dt>
<dd><p>Implements sech(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = sech(w1)</p>
</div></blockquote>
<section id="id80">
<h3>Input:<a class="headerlink" href="#id80" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id81">
<h3>Output:<a class="headerlink" href="#id81" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.acsc">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">acsc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.acsc" title="Permalink to this definition"></a></dt>
<dd><p>Implements acsc(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = acsc(w1)</p>
</div></blockquote>
<section id="id82">
<h3>Input:<a class="headerlink" href="#id82" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id83">
<h3>Output:<a class="headerlink" href="#id83" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.disp2sqw_eval">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">disp2sqw_eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">dispreln</span></em>, <em class="sig-param"><span class="pre">pars</span></em>, <em class="sig-param"><span class="pre">fwhh</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.disp2sqw_eval" title="Permalink to this definition"></a></dt>
<dd><p>Calculate sqw for a model scattering function</p>
<blockquote>
<div><p>&gt;&gt; wout = disp2sqw_eval(win,dispreln,pars,fwhh,varargin)</p>
</div></blockquote>
<section id="id84">
<h3>Input:<a class="headerlink" href="#id84" title="Permalink to this heading"></a></h3>
<blockquote>
<div><dl>
<dt>win         Dataset, or array of datasets, that provides the axes and points</dt><dd><p>for the calculation</p>
</dd>
<dt>dispreln    Handle to function that calculates the dispersion relation w(Q) and</dt><dd><p>spectral weight, s(Q)
Must have form:</p>
<blockquote>
<div><blockquote>
<div><p>[w,s] = dispreln (qh,qk,ql,p)</p>
</div></blockquote>
<dl class="simple">
<dt>where</dt><dd><dl class="simple">
<dt>qh,qk,ql    Arrays containing the coordinates of a set of points</dt><dd><p>in reciprocal lattice units</p>
</dd>
<dt>p           Vector of parameters needed by dispersion function</dt><dd><p>e.g. [A,js,gam] as intensity, exchange, lifetime</p>
</dd>
<dt>w           Array of corresponding energies, or, if more than</dt><dd><p>one dispersion relation, a cell array of arrays.</p>
</dd>
<dt>s           Array of spectral weights, or, if more than</dt><dd><p>one dispersion relation, a cell array of arrays.</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>More general form is:</dt><dd><blockquote>
<div><p>[w,s] = dispreln (qh,qk,ql,p,c1,c2,..)</p>
</div></blockquote>
<dl class="simple">
<dt>where</dt><dd><dl class="simple">
<dt>p           Typically a vector of parameters that we might want</dt><dd><p>to fit in a least-squares algorithm</p>
</dd>
<dt>c1,c2,…   Other constant parameters e.g. file name for look-up</dt><dd><p>table.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>pars        Arguments needed by the function. Most commonly, a vector of parameter</dt><dd><p>values e.g. [A,js,gam] as intensity, exchange, lifetime. If a more general
set of parameters is required by the function, then
package these into a cell array and pass that as pars. In the example
above then pars = {p, c1, c2, …}</p>
</dd>
<dt>fwhh       Parametrizes the resolution function. There are three</dt><dd><blockquote>
<div><p>possible input values of fwhh:</p>
</div></blockquote>
<dl>
<dt>double              A single FWHM value determines the FWHM of the</dt><dd><p>Gaussian resolution function</p>
</dd>
<dt>function_handle     A function that produces the FWHM value as a</dt><dd><p>function of energy transfer, it has to have the
following simple header (where omega can be a row
vector of energies:</p>
<blockquote>
<div><p>dE = resfun(omega)</p>
</div></blockquote>
</dd>
<dt>function_handle     A function handle of a function with two input</dt><dd><dl class="simple">
<dt>parameters with the following header:</dt><dd><p>I = shapefun(Emat,omega)</p>
</dd>
</dl>
<p>where Emat is a matrix with dimensions of [nQ nE]
and omega is a column vector with nQ elements. The
shapefun produces a peakshape for every Q point
centered at the given omega and normalized to one.
The output I has the same dimensions as the
input Emat.</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>Optional arguments: (varargin)</p>
<blockquote>
<div><dl>
<dt>‘-al[l]’  Requests that the calculated sqw be returned over</dt><dd><p>the whole of the domain of the input dataset. If not given, then
the function will be returned only at those points of the dataset
that contain data.
Applies only to input with no pixel information - it is ignored if
full sqw object.</p>
</dd>
<dt>‘-av[erage]’ Requests that the calculated sqw be computed for the</dt><dd><p>average values of h,k,l of the pixels in a bin, not for each
pixel individually. Reduces cost of expensive calculations.</p>
<blockquote>
<div><p>Applies only to the case of sqw object with pixel information - it is</p>
</div></blockquote>
<p>ignored if dnd type object.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id85">
<h3>Output:<a class="headerlink" href="#id85" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>wout        Output dataset or array of datasets</p>
</div></blockquote>
</section>
</dd></dl>

</section>
<section id="module-sqw.&#64;Experiment">
<span id="experiment-class"></span><h2><a class="toc-backref" href="#id89" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">Experiment</span></code> class</a><a class="headerlink" href="#module-sqw.@Experiment" title="Permalink to this heading"></a></h2>
<dl class="mat class">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.Experiment">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sqw.&#64;Experiment.</span></span><span class="sig-name descname"><span class="pre">Experiment</span></span><a class="headerlink" href="#sqw.@Experiment.Experiment" title="Permalink to this definition"></a></dt>
<dd><p>EXPERIMENT Container object for all data describing the Experiment</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.change_crystal">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;Experiment.</span></span><span class="sig-name descname"><span class="pre">change_crystal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">alignment_info</span></em>, <em class="sig-param"><span class="pre">proj</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.change_crystal" title="Permalink to this definition"></a></dt>
<dd><dl>
<dt>Change fields in the experiment with correction related to change crystal</dt><dd><p>lattice parameters and orientation</p>
<blockquote>
<div><p>&gt;&gt; obj=change_crystal(obj,alignment_info)</p>
</div></blockquote>
</dd>
</dl>
<p>obj            – initialized instance of Experiment object</p>
<dl>
<dt>alignment_info – helper class, containing the information</dt><dd><blockquote>
<div><p>about the crystal alignment, returned by refine_crystal
routine. Type:</p>
</div></blockquote>
<p>&gt;&gt; help refine_crystal  for more details.</p>
</dd>
<dt>proj            – the instance of the projection, which converts pixels</dt><dd><p>from</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.remove_legacy_alignment">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;Experiment.</span></span><span class="sig-name descname"><span class="pre">remove_legacy_alignment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">deal_info</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.remove_legacy_alignment" title="Permalink to this definition"></a></dt>
<dd><p>REMOVE_LEGACY_ALIGNMENT Change fields in the experiment with correction
to remove legacy alignment applied to the crystal earlier.</p>
<p>Inputs:
obj    – legacy realigned dnd object. Algorithm throws if the object has</p>
<blockquote>
<div><p>not been realigned using legacy algorithm.</p>
</div></blockquote>
<dl class="simple">
<dt>deal_info</dt><dd><dl class="simple">
<dt>– instance of crystal_alignment_info class, containing information</dt><dd><p>about de-alignment</p>
</dd>
</dl>
</dd>
</dl>
<p>Outputs:
obj     – Experiment object with alignment removed</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.get_efix">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;Experiment.</span></span><span class="sig-name descname"><span class="pre">get_efix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.get_efix" title="Permalink to this definition"></a></dt>
<dd><p>Return array of incident energies from all runs, contributing to
experiment.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.upgrade_legacy_alignment">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;Experiment.</span></span><span class="sig-name descname"><span class="pre">upgrade_legacy_alignment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">deal_info</span></em>, <em class="sig-param"><span class="pre">alatt</span></em>, <em class="sig-param"><span class="pre">angdeg</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.upgrade_legacy_alignment" title="Permalink to this definition"></a></dt>
<dd><p>UPGRADE_LEGACY_ALIGNMENT Change fields in the experiment with correction
to remove legacy alignment applied to the crystal earlier and apply
modern alignment to it.</p>
<p>Inputs:
obj    – legacy realigned dnd object. Algorithm throws if the object has</p>
<blockquote>
<div><p>not been realigned using legacy algorithm.</p>
</div></blockquote>
<dl class="simple">
<dt>deal_info</dt><dd><dl class="simple">
<dt>–  instance of crystal_alignment_info class, containing information</dt><dd><p>about dealignment of the legacy-aligned crystal</p>
</dd>
</dl>
</dd>
</dl>
<p>Optional
alatt   – lattice parameters with values for aligned lattice to be set.
angdeg  – lattice angles with values for aligned lattice to be set.</p>
<blockquote>
<div><p>If one is present, another one have to be present.
If these values are missing, assumes that the lattice have not
been changed.</p>
</div></blockquote>
<p>Outputs:
wout    – dnd object according to the new alignment algorithm.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.set_instrument">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;Experiment.</span></span><span class="sig-name descname"><span class="pre">set_instrument</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">instr_or_fun</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.set_instrument" title="Permalink to this definition"></a></dt>
<dd><p>add or reset instrument, related to the given experiment class</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.set_mod_pulse">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;Experiment.</span></span><span class="sig-name descname"><span class="pre">set_mod_pulse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">pulse_model</span></em>, <em class="sig-param"><span class="pre">pm_par</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.set_mod_pulse" title="Permalink to this definition"></a></dt>
<dd><p>Set moderator pulse model on all unique instruments, contributed in the
experiment
Input:
——</p>
<blockquote>
<div><p>obj         Experiment object
pulse_model Pulse shape model name e.g. ‘ikcarp’
pp          Pulse shape parameters: row vector for a single set of parameters</p>
<blockquote>
<div><p>or a 2D array, one row per spe data set for each instrument
of the sqw object(s).</p>
</div></blockquote>
</div></blockquote>
<section id="id86">
<h3>Output:<a class="headerlink" href="#id86" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>obj         Modified experiment</p>
</div></blockquote>
</section>
</dd></dl>

</section>
<section id="pixeldata-class">
<h2><a class="toc-backref" href="#id90" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">PixelData</span></code> class</a><a class="headerlink" href="#pixeldata-class" title="Permalink to this heading"></a></h2>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Contributing.html" class="btn btn-neutral float-left" title="Contributing to Horace" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="General_disclaimer.html" class="btn btn-neutral float-right" title="General disclaimer" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2006-2023, STFC RAL.
      <span class="lastupdated">Last updated on Aug 4, 2023, 3:35:57 PM.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
<br><br>
<a href="https://github.com/pace-neutrons/Horace/edit/master/documentation/user_docs/docs/API_Reference.rst">Click here to edit</a> or <a href="https://github.com/pace-neutrons/Horace/edit/master/documentation/user_docs/docs/new_page.rst">Click here to add new page</a> (requires <a href="https://github.com/login">GitHub account</a>).
<br>
For more info on editing <a href="Contributing.html">click here</a>.


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>