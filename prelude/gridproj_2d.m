function  [p1_out, p2_out, ri_out, ei_out] = gridproj_2d (data, pax1, pax1_lo, pax1_hi, pax2, pax2_lo, pax2_hi);
% Project data from binary grid file to the 2D volume (eg. (k,e)) defined by the projection directions pax1 and pax2
% with a criterion for allowed values of pax (pax_lo and pax_hi). This routine accepts the type of file that is
% generated by grid_hkle.m
%
%   Input:
%   -------
%   data is a workspace with the following content:
%       data.nhv = length(data.hv)
%       data.nkv = length(data.kv)
%       data.nlv = length(data.lv)
%       data.nev = length(data.ev)
%       data.hv
%       data.kv
%       data.lv
%       data.ev
%       data.rint(length(data.hv),length(data.kv),length(data.lv),length(data.ev)) float32
%       data.eint(length(data.hv),length(data.kv),length(data.lv),length(data.ev)) float32
%       data.nint(length(data.hv),length(data.kv),length(data.lv),length(data.ev)) int16
%
%       data.rint is the cumulative intensity in the grid defined by the bin boundaries 
%       in data.hv,data.kv,data.lv,data.ev.
%       data.eint is the cumulative variance in the grid defined by the bin boundaries 
%       in data.hv,data.kv,data.lv,data.ev.
%       Number of pixels that contributed to a grid point is given by data.nint
%
%   pax1, pax1_lo, pax1_hi -|-define the projection direction and the range to be included in projection
%   pax2, pax2_lo, pax2_hi -|
%       The remaining projection axes, p1 and p2, are those left after elimination of pax1, pax2 from the list h,k,l,e
%       e.g. pax1,pax2 = 2,4    p1,p2 = 1,3
%
%   Output:
%   -------
%       p1: vector of p1-values. Will be equal to the p1-grid values in the
%           binary input file defined by the projection direction.
%       p2: vector of 2l values. Will be equal to the p2-grid values in the
%           binary input file defined by the projection direction.. 
%       ri(length(p1),length(p2)): Projected intensity values.
%           any pixels in this grid that have not received coverage will be
%           given the value -1 as a flag. NaN would be more logical but
%           that causes trouble in sliceomatic. 
%

% Project down pax1, as in gridproj_3d:
% ================================
disp('Doing projection down first axis')
if pax1==1,
    % h is the projection axis
    % generate projection arrays
    p1 = data.kv;
    p2 = data.lv;
    p3 = data.ev;
    ri = zeros(data.nkv,data.nlv,data.nev);
    ei = zeros(data.nkv,data.nlv,data.nev);
    nri = zeros(data.nkv,data.nlv,data.nev);

    % sum up the intensities and "hits"
    lis = find(data.hv>=pax1_lo & data.hv<=pax1_hi);
    ri = squeeze(sum(data.rint(lis,:,:,:),1));
    ei = squeeze(sum(data.eint(lis,:,:,:),1));
    nri = squeeze(sum(data.nint(lis,:,:,:),1));
elseif pax1==2,
    % k is the projection axis
    % generate projection arrays
    p1 = data.hv;
    p2 = data.lv;
    p3 = data.ev;
    ri = zeros(data.nhv,data.nlv,data.nev);
    ei = zeros(data.nhv,data.nlv,data.nev);
    nri = zeros(data.nhv,data.nlv,data.nev);

    % sum up the intensities and "hits"
    lis = find(data.kv>=pax1_lo & data.kv<=pax1_hi);
    ri = squeeze(sum(data.rint(:,lis,:,:),2));
    ei = squeeze(sum(data.eint(:,lis,:,:),2));
    nri = squeeze(sum(data.nint(:,lis,:,:),2));
elseif pax1==3,
    % l is the projection axis
    % generate projection arrays
    p1 = data.hv;
    p2 = data.kv;
    p3 = data.ev;
    ri = zeros(data.nhv,data.nkv,data.nev);
    ei = zeros(data.nhv,data.nkv,data.nev);
    nri = zeros(data.nhv,data.nkv,data.nev);

    % sum up the intensities and "hits"
    lis = find(data.lv>=pax1_lo & data.lv<=pax1_hi);
    ri = squeeze(sum(data.rint(:,:,lis,:),3));
    ei = squeeze(sum(data.eint(:,:,lis,:),3));
    nri = squeeze(sum(data.nint(:,:,lis,:),3));
elseif pax1==4,
    % e is the projection axis
    % generate projection arrays
    p1 = data.hv;
    p2 = data.kv;
    p3 = data.lv;
    ri = zeros(data.nhv,data.nkv,data.nlv);
    ei = zeros(data.nhv,data.nkv,data.nlv);
    nri = zeros(data.nhv,data.nkv,data.nlv);

    % sum up the intensities and "hits"
    lis = find(data.ev>=pax1_lo & data.ev<=pax1_hi);
    ri = squeeze(sum(data.rint(:,:,:,lis),4));
    ei = squeeze(sum(data.rint(:,:,:,lis),4));
    nri = squeeze(sum(data.nint(:,:,:,lis),4));
end

% Now project down pax2:
% ================================
disp('Doing projection down second axis')
ax=find([1,2,3,4]~=pax1);   % list of remaining axes after projecting down pax1
p_ax=find(ax==pax2);        % index of 2nd projection axis in p1,p2,p3
out_ax=find(ax~=pax2);      % list of indices in p1,p2,p3 of the output axes

% Get output bin boundaries along the two remaining axes:
if out_ax(1)==1
    p1_out = p1;
elseif out_ax(1)==2
    p1_out = p2;
elseif out_ax(1)==3
    p1_out = p3;
end
if out_ax(2)==1
    p2_out = p1;
elseif out_ax(2)==2
    p2_out = p2;
elseif out_ax(2)==3
    p2_out = p3;
end

ri_out = zeros(length(p1_out),length(p2_out));
ei_out = zeros(length(p1_out),length(p2_out));
nri_out = zeros(length(p1_out),length(p2_out));

if p_ax==1,
    % sum up the intensities and "hits"
    lis = find(p1>=pax2_lo & p1<=pax2_hi);
    ri_out = squeeze(sum(ri(lis,:,:),1));
    ei_out = squeeze(sum(ei(lis,:,:),1));
    nri_out = squeeze(sum(nri(lis,:,:),1));
elseif p_ax==2,
    % sum up the intensities and "hits"
    lis = find(p2>=pax2_lo & p2<=pax2_hi);
    ri_out = squeeze(sum(ri(:,lis,:),2));
    ei_out = squeeze(sum(ei(:,lis,:),2));
    nri_out = squeeze(sum(nri(:,lis,:),2));
elseif p_ax==3,
    % sum up the intensities and "hits"
    lis = find(p3>=pax2_lo & p3<=pax2_hi);
    ri_out = squeeze(sum(ri(:,:,lis),3));
    ei_out = squeeze(sum(ei(:,:,lis),3));
    nri_out = squeeze(sum(nri(:,:,lis),3));
end

% finally normalize the intensity values and store non-probed pixel marker
lis = find(nri_out~=0);
ri_out(lis) = ri_out(lis)./nri_out(lis);
ei_out(lis) = sqrt(ei_out(lis))./nri_out(lis);
lis = find(nri_out==0);
ri_out(lis)=-1;
ei_out(lis)=0;