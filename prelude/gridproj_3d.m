function  [p1,p2,p3,ri] = gridproj_3d(data, pax, pax_lo, pax_hi);
% Project data from binary grid file to the 3D volume (eg. (kle)) defined by the projection direction pax
% with a criterion for allowed values of pax (pax_lo and pax_hi). This routine accepts the type of file that is
% generated by grid_hkle.m
%
%   Input:
%   -------
%   data is a workspace with the following content:
%       data.nhv = length(data.hv)
%       data.nkv = length(data.kv)
%       data.nlv = length(data.lv)
%       data.nev = length(data.ev)
%       data.hv
%       data.kv
%       data.lv
%       data.ev
%       data.rint(length(data.hv),length(data.kv),length(data.lv),length(data.ev)) float32
%       data.eint(length(data.hv),length(data.kv),length(data.lv),length(data.ev)) float32
%       data.nint(length(data.hv),length(data.kv),length(data.lv),length(data.ev)) int16
%
%       data.rint is the cumulative intensity in the grid defined by the bin boundaries 
%       in data.hv,data.kv,data.lv,data.ev.
%       data.eint is the cumulative variance in the grid defined by the bin boundaries 
%       in data.hv,data.kv,data.lv,data.ev.
%       Number of pixels that contributed to a grid point is given by data.nint
%
%   pax, pax_lo, pax_hi define the projection direction and the range to be included in projection
%       pax = 1: h-axis     remaining x,y,z axes are:  k,l,e
%             2: k-axis     remaining x,y,z axes are:  h,l,e
%             3: l-axis     remaining x,y,z axes are:  h,k,e
%             4: e-axis     remaining x,y,z axes are:  h,k,l
%
%   Output:
%   -------
%       p1: vector of p1-values. Will be equal to the p1-grid values in the
%           binary input file defined by the projection direction.
%       p2: vector of 2l values. Will be equal to the p2-grid values in the
%           binary input file defined by the projection direction.. 
%       p3: vector of p3 values. Will be equal to the p3-grid values in the
%           binary input file defined by the projection direction.. 
%       ri(length(p1),length(p2),length(p3)): Projected intensity values.
%           any pixels in this grid that have not received coverage will be
%           given the value -1 as a flag. NaN would be more logical but
%           that causes trouble in sliceomatic. 
%

% do the projection along the defined axis
if pax==1,
    % h is the projection axis
    disp('projecting along h');
    % generate projection arrays
    p1  =   data.kv;
    p2  =   data.lv;
    p3  =   data.ev;
    ri  =   zeros(data.nkv,data.nlv,data.nev);
    nri  =   zeros(data.nkv,data.nlv,data.nev);

    % sum up the intensities and "hits"
    lis =   find(data.hv>=pax_lo & data.hv<=pax_hi);
    ri =   squeeze(sum(data.rint(lis,:,:,:),1));
    nri  =   squeeze(sum(data.nint(lis,:,:,:),1));
elseif pax==2,
    % k is the projection axis
    disp('projecting along k');
    % generate projection arrays
    p1  =   data.hv;
    p2  =   data.lv;
    p3  =   data.ev;
    ri  =   zeros(data.nhv,data.nlv,data.nev);
    nri  =   zeros(data.nhv,data.nlv,data.nev);

    % sum up the intensities and "hits"
    lis =   find(data.kv>=pax_lo & data.kv<=pax_hi);
    ri =   squeeze(sum(data.rint(:,lis,:,:),2));
    nri  =   squeeze(sum(data.nint(:,lis,:,:),2));
elseif pax==3,
    % l is the projection axis
    disp('projecting along l');
    % generate projection arrays
    p1  =   data.hv;
    p2  =   data.kv;
    p3  =   data.ev;
    ri  =   zeros(data.nhv,data.nkv,data.nev);
    nri  =   zeros(data.nhv,data.nkv,data.nev);

    % sum up the intensities and "hits"
    lis =   find(data.lv>=pax_lo & data.lv<=pax_hi);
    ri =   squeeze(sum(data.rint(:,:,lis,:),3));
    nri  =   squeeze(sum(data.nint(:,:,lis,:),3));
elseif pax==4,
    % e is the projection axis
    disp('projecting along E');
    % generate projection arrays
    p1  =   data.hv;
    p2  =   data.kv;
    p3  =   data.lv;
    ri  =   zeros(data.nhv,data.nkv,data.nlv);
    nri  =   zeros(data.nhv,data.nkv,data.nlv);

    % sum up the intensities and "hits"
    lis =   find(data.ev>=pax_lo & data.ev<=pax_hi);
    ri =   squeeze(sum(data.rint(:,:,:,lis),4));
    nri  =   squeeze(sum(data.nint(:,:,:,lis),4));
end

% finally normalize the intensity values and store non-probed pixel marker
lis = find(nri~=0);
ri(lis) = ri(lis)./nri(lis);
lis = find(nri==0);
ri(lis)=-1;